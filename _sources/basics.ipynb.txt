{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Basic concepts"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Basic input and output"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The traditional \"Hello, world\" program is very simple in Python. You can run the program by selecting the cell by mouse and pressing control-enter on keyboard. Try editing the string in the quotes and rerunning the program."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hello world!\n"
     ]
    }
   ],
   "source": [
    "print(\"Hello world!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Multiple strings can be printed. By default, they are concatenated with a space:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hello, John! How are you?\n"
     ]
    }
   ],
   "source": [
    "print(\"Hello,\", \"John!\", \"How are you?\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In the print function, numerical expression are first evaluated and then automatically converted to strings. Subsequently the strings are concatenated with spaces:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 plus 2 equals 3\n"
     ]
    }
   ],
   "source": [
    "print(1, \"plus\", 2, \"equals\", 1+2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Reading textual input from the user can be achieved with the input function. The input function is given a string parameter, which is printed and prompts the user to give input. In the example below, the string entered by the user is stored the variable `name`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Give me your name: Sari\n",
      "Hello, Sari\n"
     ]
    }
   ],
   "source": [
    "name=input(\"Give me your name: \")\n",
    "print(\"Hello,\", name)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Indentation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Repetition is possible with the for loop. Note that the body of for loop is indented whith a tabulator or four spaces.\n",
    "Unlike in some other languages, braces are not needed to denote the body of the loop. When the indentation stops the body of the loop ends."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hello\n",
      "Hello\n",
      "Hello\n",
      "Bye!\n"
     ]
    }
   ],
   "source": [
    "for i in range(3):\n",
    "    print(\"Hello\")\n",
    "print(\"Bye!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Indentation applies to other compound statements as well, such as bodies of functions, different branches of an if statement, and while loops. We shall see examples of these later."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The range(3) expression above actually results with the sequence of integers 0, 1, and 2. So, the range is a half-open interval with the end point excluded from the range. In general, expression range(n) gives integers 0, 1, 2, ..., n-1. Modify the above program to make it also print the value of variable i at each iteration. Rerun the code with control-enter."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise 1 (hello world)</div>\n",
    "Fill in the missing piece in the solution stub to make it print the following:\n",
    "\n",
    "`Hello, world!`\n",
    "\n",
    "Make sure you use correct indenting."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise 2 (compliment)</div>\n",
    "Fill in the stub solution to make the program work as follows. The program should ask the user for an input, and the print an answer as the examples below show. The string the user entered is shown below in red.\n",
    "\n",
    "What country are you from? <font color='red'>Sweden</font>  \n",
    "I have heard that Sweden is a beautiful country.\n",
    "\n",
    "What country are you from? <font color='red'>Chile</font>  \n",
    "I have heard that Chile is a beautiful country."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\">Exercise 3 (multiplication)</div> \n",
    "Make a program that gives the following output. You must use a for loop in your solution.\n",
    "\n",
    "```\n",
    "4 multiplied by 0 is 0\n",
    "4 multiplied by 1 is 4\n",
    "4 multiplied by 2 is 8\n",
    "4 multiplied by 3 is 12\n",
    "4 multiplied by 4 is 16\n",
    "4 multiplied by 5 is 20\n",
    "4 multiplied by 6 is 24\n",
    "4 multiplied by 7 is 28\n",
    "4 multiplied by 8 is 32\n",
    "4 multiplied by 9 is 36\n",
    "4 multiplied by 10 is 40\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<style>\n",
       "\n",
       "html {\n",
       "  font-size: 62.5% !important; }\n",
       "body {\n",
       "  font-size: 1.5em !important; /* currently ems cause chrome bug misinterpreting rems on body element */\n",
       "  line-height: 1.6 !important;\n",
       "  font-weight: 400 !important;\n",
       "  font-family: \"Raleway\", \"HelveticaNeue\", \"Helvetica Neue\", Helvetica, Arial, sans-serif !important;\n",
       "  color: #222 !important; }\n",
       "\n",
       "div{ border-radius: 0px !important;  }\n",
       "div.CodeMirror-sizer{ background: rgb(244, 244, 248) !important; }\n",
       "div.input_area{ background: rgb(244, 244, 248) !important; }\n",
       "\n",
       "div.out_prompt_overlay:hover{ background: rgb(244, 244, 248) !important; }\n",
       "div.input_prompt:hover{ background: rgb(244, 244, 248) !important; }\n",
       "\n",
       "h1, h2, h3, h4, h5, h6 {\n",
       "  color: #333 !important;\n",
       "  margin-top: 0 !important;\n",
       "  margin-bottom: 2rem !important;\n",
       "  font-weight: 300 !important; }\n",
       "h1 { font-size: 4.0rem !important; line-height: 1.2 !important;  letter-spacing: -.1rem !important;}\n",
       "h2 { font-size: 3.6rem !important; line-height: 1.25 !important; letter-spacing: -.1rem !important; }\n",
       "h3 { font-size: 3.0rem !important; line-height: 1.3 !important;  letter-spacing: -.1rem !important; }\n",
       "h4 { font-size: 2.4rem !important; line-height: 1.35 !important; letter-spacing: -.08rem !important; }\n",
       "h5 { font-size: 1.8rem !important; line-height: 1.5 !important;  letter-spacing: -.05rem !important; }\n",
       "h6 { font-size: 1.5rem !important; line-height: 1.6 !important;  letter-spacing: 0 !important; }\n",
       "\n",
       "@media (min-width: 550px) {\n",
       "  h1 { font-size: 5.0rem !important; }\n",
       "  h2 { font-size: 4.2rem !important; }\n",
       "  h3 { font-size: 3.6rem !important; }\n",
       "  h4 { font-size: 3.0rem !important; }\n",
       "  h5 { font-size: 2.4rem !important; }\n",
       "  h6 { font-size: 1.5rem !important; }\n",
       "}\n",
       "\n",
       "p {\n",
       "  margin-top: 0 !important; }\n",
       "  \n",
       "a {\n",
       "  color: #1EAEDB !important; }\n",
       "a:hover {\n",
       "  color: #0FA0CE !important; }\n",
       "  \n",
       "code {\n",
       "  padding: .2rem .5rem !important;\n",
       "  margin: 0 .2rem !important;\n",
       "  font-size: 90% !important;\n",
       "  white-space: nowrap !important;\n",
       "  background: #F1F1F1 !important;\n",
       "  border: 1px solid #E1E1E1 !important;\n",
       "  border-radius: 4px !important; }\n",
       "pre > code {\n",
       "  display: block !important;\n",
       "  padding: 1rem 1.5rem !important;\n",
       "  white-space: pre !important; }\n",
       "  \n",
       "button{ border-radius: 0px !important; }\n",
       ".navbar-inner{ background-image: none !important;  }\n",
       "select, textarea{ border-radius: 0px !important; }\n",
       "\n",
       "</style>"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from IPython.core.display import HTML\n",
    "from urllib.request import urlopen\n",
    "HTML(urlopen('http://bit.ly/1Bf5Hft').read().decode('utf-8'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Variables and data types\n",
    "\n",
    "We saw already earlier that assigning a value to variable is very simple:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n"
     ]
    }
   ],
   "source": [
    "a=1\n",
    "print(a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that we did not need to introduce the variable a in any way. No type was given for the variable. Python automatically detected that the type of a must be int. We can query the type of a variable with the builtin function type:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "int"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "type(a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note also that the type of a variable is not fixed:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "str"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a=\"some text\"\n",
    "type(a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In Python the type of a variable is not attached to the name of the variable, like in C for instance, but instead with the actual value. This is called dynamic typing."
   ]
  },
  {
   "attachments": {
    "typing.svg": {
     "image/svg+xml": [
      "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIHN2Z19zdGFjayAoaHR0cDovL2dpdGh1Yi5jb20vYXN0cmF3L3N2Z19zdGFjaykgLS0+Cgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHZlcnNpb249IjEuMSIKICAgd2lkdGg9IjkzNC4yNjExMSIKICAgaGVpZ2h0PSIyNzYuMDMzMjMiCiAgIGlkPSJzdmc3NiIKICAgc29kaXBvZGk6ZG9jbmFtZT0idHlwaW5nLnN2ZyIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45Mi4zICgyNDA1NTQ2LCAyMDE4LTAzLTExKSI+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhODAiPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMSIKICAgICBvYmplY3R0b2xlcmFuY2U9IjEwIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwIgogICAgIGd1aWRldG9sZXJhbmNlPSIxMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTg3NyIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4MjEiCiAgICAgaWQ9Im5hbWVkdmlldzc4IgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBmaXQtbWFyZ2luLXRvcD0iMCIKICAgICBmaXQtbWFyZ2luLWxlZnQ9IjAiCiAgICAgZml0LW1hcmdpbi1yaWdodD0iMCIKICAgICBmaXQtbWFyZ2luLWJvdHRvbT0iMCIKICAgICBpbmtzY2FwZTp6b29tPSIwLjMxMjUzMzMzIgogICAgIGlua3NjYXBlOmN4PSI1MTAuNzEzNjciCiAgICAgaW5rc2NhcGU6Y3k9Ii05Mi4wMzM4ODciCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJzdmc3NiIgLz4KICA8ZGVmcwogICAgIGlkPSJkZWZzMiIgLz4KICA8ZwogICAgIGlkPSJpZDA6aWQwIgogICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuMDc4ODc0MzEsMCwwLDAuMDc4ODU3NjMsLTM5LjY3ODgyNCwtMTkuNjgyODY0KSI+CiAgICA8ZwogICAgICAgaWQ9ImczNSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmUiPgogICAgICA8IS0tIExpbmUgLS0+CiAgICAgIDxyZWN0CiAgICAgICAgIHg9IjUzMTAiCiAgICAgICAgIHk9IjU0MCIKICAgICAgICAgd2lkdGg9IjEwODAiCiAgICAgICAgIGhlaWdodD0iMzE5NSIKICAgICAgICAgaWQ9InJlY3Q0IgogICAgICAgICBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjMwcHgiIC8+CiAgICAgIDwhLS0gTGluZSAtLT4KICAgICAgPHJlY3QKICAgICAgICAgeD0iNTQ5MCIKICAgICAgICAgeT0iOTkwIgogICAgICAgICB3aWR0aD0iNzY1IgogICAgICAgICBoZWlnaHQ9IjE4MCIKICAgICAgICAgaWQ9InJlY3Q2IgogICAgICAgICBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjMwcHgiIC8+CiAgICAgIDwhLS0gTGluZSAtLT4KICAgICAgPHJlY3QKICAgICAgICAgeD0iNTQ5MCIKICAgICAgICAgeT0iMjA3MCIKICAgICAgICAgd2lkdGg9Ijc2NSIKICAgICAgICAgaGVpZ2h0PSIxODAiCiAgICAgICAgIGlkPSJyZWN0OCIKICAgICAgICAgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozMHB4IiAvPgogICAgICA8IS0tIExpbmUgLS0+CiAgICAgIDxwb2x5bGluZQogICAgICAgICBwb2ludHM9IiA5NDUsMTk4MCAyMzQwLDE5ODAiCiAgICAgICAgIGlkPSJwb2x5bGluZTEwIgogICAgICAgICBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjhweDtzdHJva2UtZGFzaGFycmF5OjQwLCA0MCIgLz4KICAgICAgPCEtLSBMaW5lIC0tPgogICAgICA8cmVjdAogICAgICAgICB4PSI2MzAiCiAgICAgICAgIHk9IjE2NjUiCiAgICAgICAgIHdpZHRoPSIxOTM1IgogICAgICAgICBoZWlnaHQ9IjYzMCIKICAgICAgICAgaWQ9InJlY3QxMiIKICAgICAgICAgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozMHB4IiAvPgogICAgICA8IS0tIExpbmUgLS0+CiAgICAgIDxwb2x5bGluZQogICAgICAgICBwb2ludHM9IiAyNTY1LDE4MDAgMjU2NywxNzk5IDI1NzAsMTc5NyAyNTc3LDE3OTQgMjU4OCwxNzg5IDI2MDMsMTc4MiAyNjIzLDE3NzIgMjY0OCwxNzYwICAyNjc5LDE3NDYgMjcxMywxNzMwIDI3NTMsMTcxMiAyNzk1LDE2OTIgMjg0MSwxNjcxIDI4ODksMTY0OSAyOTM5LDE2MjYgMjk5MCwxNjAzICAzMDQxLDE1ODAgMzA5MiwxNTU4IDMxNDIsMTUzNiAzMTkxLDE1MTUgMzIzOSwxNDk0IDMyODYsMTQ3NSAzMzMxLDE0NTYgMzM3NSwxNDM5ICAzNDE3LDE0MjIgMzQ1OCwxNDA3IDM0OTgsMTM5MiAzNTM3LDEzNzggMzU3NSwxMzY1IDM2MTIsMTM1MyAzNjQ5LDEzNDEgMzY4NiwxMzMwICAzNzIyLDEzMTkgMzc1OSwxMzA5IDM3OTUsMTI5OSAzODMzLDEyOTAgMzg2NiwxMjgyIDM5MDAsMTI3NCAzOTM1LDEyNjYgMzk3MCwxMjU5ICA0MDA3LDEyNTIgNDA0NCwxMjQ1IDQwODIsMTIzOCA0MTIyLDEyMzEgNDE2MywxMjI0IDQyMDYsMTIxOCA0MjUwLDEyMTEgNDI5NywxMjA1ICA0MzQ1LDExOTggNDM5NiwxMTkyIDQ0NDgsMTE4NSA0NTAzLDExNzggNDU2MCwxMTcyIDQ2MTksMTE2NSA0NjgwLDExNTggNDc0MiwxMTUyICA0ODA1LDExNDUgNDg2OSwxMTM5IDQ5MzMsMTEzMiA0OTk3LDExMjYgNTA1OSwxMTIwIDUxMjAsMTExNCA1MTc3LDExMDggNTIzMSwxMTAzICA1MjgxLDEwOTkgNTMyNiwxMDk1IDUzNjUsMTA5MSA1Mzk5LDEwODggNTQyNywxMDg2IDU0NDksMTA4NCA1NDY1LDEwODIgNTQ5MCwxMDgwICIKICAgICAgICAgaWQ9InBvbHlsaW5lMTQiCiAgICAgICAgIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MzBweDtzdHJva2UtbGluZWpvaW46YmV2ZWwiIC8+CiAgICAgIDwhLS0gRm9yd2FyZCBhcnJvdyB0byBwb2ludCAwLDAgLS0+CiAgICAgIDxwb2x5Z29uCiAgICAgICAgIHBvaW50cz0iIgogICAgICAgICBzdHJva2UtbWl0ZXJsaW1pdD0iOCIKICAgICAgICAgaWQ9InBvbHlnb24xNiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NjBweDtzdHJva2UtbWl0ZXJsaW1pdDo4IiAvPgogICAgICA8IS0tIExpbmUgLS0+CiAgICAgIDxkZWZzCiAgICAgICAgIGlkPSJkZWZzMjEiPgogICAgICAgIDxjbGlwUGF0aAogICAgICAgICAgIGlkPSJpZDA6Y3AwIj4KICAgICAgICAgIDxwYXRoCiAgICAgICAgICAgICBkPSJNIDQ4MCwyNDkgSCA2NDIzIFYgMzc2OCBIIDQ4MCBaIG0gMjgwMiwxMjYwIC0yNCwtNTUgLTI0MSwxMTcgMTUsMzMgeiIKICAgICAgICAgICAgIGlkPSJwYXRoMTgiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIiAvPgogICAgICAgIDwvY2xpcFBhdGg+CiAgICAgIDwvZGVmcz4KICAgICAgPHBvbHlsaW5lCiAgICAgICAgIHBvaW50cz0iIDI1NjUsMjE2MCAyNTY3LDIxNjAgMjU3MCwyMTYxIDI1NzgsMjE2MyAyNTg5LDIxNjUgMjYwNSwyMTY4IDI2MjYsMjE3MiAyNjUyLDIxNzggIDI2ODQsMjE4NCAyNzIxLDIxOTEgMjc2MywyMTk5IDI4MDksMjIwOCAyODU5LDIyMTggMjkxMSwyMjI4IDI5NjYsMjIzOCAzMDIyLDIyNDggIDMwNzksMjI1OSAzMTM2LDIyNjkgMzE5MywyMjc5IDMyNDgsMjI4OSAzMzAzLDIyOTggMzM1NSwyMzA3IDM0MDcsMjMxNSAzNDU2LDIzMjIgIDM1MDQsMjMyOSAzNTQ5LDIzMzYgMzU5MywyMzQyIDM2MzYsMjM0NyAzNjc3LDIzNTIgMzcxNywyMzU2IDM3NTUsMjM1OSAzNzkyLDIzNjIgIDM4MjksMjM2NSAzODY1LDIzNjcgMzkwMCwyMzY4IDM5MzUsMjM2OSAzOTcwLDIzNzAgNDAwNSwyMzcwIDQwNDAsMjM3MCA0MDc1LDIzNjkgIDQxMTAsMjM2OCA0MTQ1LDIzNjcgNDE4MSwyMzY1IDQyMTgsMjM2MiA0MjU1LDIzNTkgNDI5MywyMzU2IDQzMzMsMjM1MiA0Mzc0LDIzNDcgIDQ0MTcsMjM0MiA0NDYxLDIzMzYgNDUwNiwyMzI5IDQ1NTQsMjMyMiA0NjAzLDIzMTUgNDY1NSwyMzA3IDQ3MDcsMjI5OCA0NzYyLDIyODkgIDQ4MTcsMjI3OSA0ODc0LDIyNjkgNDkzMSwyMjU5IDQ5ODgsMjI0OCA1MDQ0LDIyMzggNTA5OSwyMjI4IDUxNTEsMjIxOCA1MjAxLDIyMDggIDUyNDcsMjE5OSA1Mjg5LDIxOTEgNTMyNiwyMTg0IDUzNTgsMjE3OCA1Mzg0LDIxNzIgNTQwNSwyMTY4IDU0MjEsMjE2NSA1NDQ1LDIxNjAgIgogICAgICAgICBjbGlwLXBhdGg9InVybCgjaWQwOmNwMCkiCiAgICAgICAgIGlkPSJwb2x5bGluZTIzIgogICAgICAgICBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjMwcHg7c3Ryb2tlLWxpbmVqb2luOmJldmVsIiAvPgogICAgICA8IS0tIEZvcndhcmQgYXJyb3cgdG8gcG9pbnQgMzA0MSwxNTgwIC0tPgogICAgICA8cG9seWdvbgogICAgICAgICBwb2ludHM9IjMyODIsMTUwOSAzMjU4LDE0NTQgMzE2MCwxNTI5ICIKICAgICAgICAgc3Ryb2tlLW1pdGVybGltaXQ9IjgiCiAgICAgICAgIGlkPSJwb2x5Z29uMjUiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjYwcHg7c3Ryb2tlLW1pdGVybGltaXQ6OCIgLz4KICAgICAgPCEtLSBUZXh0IC0tPgogICAgICA8dGV4dAogICAgICAgICB4bWw6c3BhY2U9InByZXNlcnZlIgogICAgICAgICB4PSIxMzA1IgogICAgICAgICB5PSIyMjA1IgogICAgICAgICBmb250LXN0eWxlPSJub3JtYWwiCiAgICAgICAgIGZvbnQtd2VpZ2h0PSJub3JtYWwiCiAgICAgICAgIGZvbnQtc2l6ZT0iMjQwIgogICAgICAgICBpZD0idGV4dDI3IgogICAgICAgICBzdHlsZT0iZm9udC1zdHlsZTpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToyNDBweDtmb250LWZhbWlseTpUaW1lczt0ZXh0LWFuY2hvcjpzdGFydDtmaWxsOiMwMDAwMDAiPnR5cGU8L3RleHQ+CiAgICAgIDwhLS0gVGV4dCAtLT4KICAgICAgPHRleHQKICAgICAgICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgICAgICAgeD0iNDk1IgogICAgICAgICB5PSI3MjAiCiAgICAgICAgIGZvbnQtc3R5bGU9Im5vcm1hbCIKICAgICAgICAgZm9udC13ZWlnaHQ9Im5vcm1hbCIKICAgICAgICAgZm9udC1zaXplPSIyODgiCiAgICAgICAgIGlkPSJ0ZXh0MjkiCiAgICAgICAgIHN0eWxlPSJmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjI4OHB4O2ZvbnQtZmFtaWx5OlRpbWVzO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMCI+QyAtIHN0YXRpYyB0eXBpbmc8L3RleHQ+CiAgICAgIDwhLS0gVGV4dCAtLT4KICAgICAgPHRleHQKICAgICAgICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgICAgICAgeD0iNTI2NSIKICAgICAgICAgeT0iMzYwIgogICAgICAgICBmb250LXN0eWxlPSJub3JtYWwiCiAgICAgICAgIGZvbnQtd2VpZ2h0PSJub3JtYWwiCiAgICAgICAgIGZvbnQtc2l6ZT0iMjQwIgogICAgICAgICBpZD0idGV4dDMxIgogICAgICAgICBzdHlsZT0iZm9udC1zdHlsZTpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToyNDBweDtmb250LWZhbWlseTpUaW1lczt0ZXh0LWFuY2hvcjpzdGFydDtmaWxsOiMwMDAwMDAiPm1lbW9yeTwvdGV4dD4KICAgICAgPCEtLSBUZXh0IC0tPgogICAgICA8dGV4dAogICAgICAgICB4bWw6c3BhY2U9InByZXNlcnZlIgogICAgICAgICB4PSI2MzAiCiAgICAgICAgIHk9IjE4OTAiCiAgICAgICAgIGZvbnQtc3R5bGU9Im5vcm1hbCIKICAgICAgICAgZm9udC13ZWlnaHQ9Im5vcm1hbCIKICAgICAgICAgZm9udC1zaXplPSIyNDAiCiAgICAgICAgIGlkPSJ0ZXh0MzMiCiAgICAgICAgIHN0eWxlPSJmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjI0MHB4O2ZvbnQtZmFtaWx5OlRpbWVzO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMCI+dmFyaWFibGVfbmFtZTwvdGV4dD4KICAgIDwvZz4KICA8L2c+CiAgPGcKICAgICBpZD0iaWQxOmlkMSIKICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLjA3ODg3NDMxLDAsMCwwLjA3ODg1NzYzLDQyOS4wNzExOCwtMTkuNjgyODY0KSI+CiAgICA8ZwogICAgICAgaWQ9Imc3MyIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmUiPgogICAgICA8IS0tIExpbmUgLS0+CiAgICAgIDxyZWN0CiAgICAgICAgIHg9IjUzMTAiCiAgICAgICAgIHk9IjU0MCIKICAgICAgICAgd2lkdGg9IjEwODAiCiAgICAgICAgIGhlaWdodD0iMzE5NSIKICAgICAgICAgaWQ9InJlY3QzOCIKICAgICAgICAgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozMHB4IiAvPgogICAgICA8IS0tIExpbmUgLS0+CiAgICAgIDxyZWN0CiAgICAgICAgIHg9IjU4NSIKICAgICAgICAgeT0iMTY2NSIKICAgICAgICAgd2lkdGg9IjE5ODAiCiAgICAgICAgIGhlaWdodD0iNjMwIgogICAgICAgICBpZD0icmVjdDQwIgogICAgICAgICBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjMwcHgiIC8+CiAgICAgIDwhLS0gTGluZSAtLT4KICAgICAgPHJlY3QKICAgICAgICAgeD0iNTQ5MCIKICAgICAgICAgeT0iOTkwIgogICAgICAgICB3aWR0aD0iNzY1IgogICAgICAgICBoZWlnaHQ9IjU4NSIKICAgICAgICAgaWQ9InJlY3Q0MiIKICAgICAgICAgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozMHB4IiAvPgogICAgICA8IS0tIExpbmUgLS0+CiAgICAgIDxyZWN0CiAgICAgICAgIHg9IjU0OTAiCiAgICAgICAgIHk9IjIwNzAiCiAgICAgICAgIHdpZHRoPSI3NjUiCiAgICAgICAgIGhlaWdodD0iNjc1IgogICAgICAgICBpZD0icmVjdDQ0IgogICAgICAgICBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjMwcHgiIC8+CiAgICAgIDwhLS0gTGluZSAtLT4KICAgICAgPHBvbHlsaW5lCiAgICAgICAgIHBvaW50cz0iIDU2MjUsMTMwNSA2MTY1LDEzMDUiCiAgICAgICAgIGlkPSJwb2x5bGluZTQ2IgogICAgICAgICBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjhweDtzdHJva2UtZGFzaGFycmF5OjQwLCA0MCIgLz4KICAgICAgPCEtLSBMaW5lIC0tPgogICAgICA8cG9seWxpbmUKICAgICAgICAgcG9pbnRzPSIgNTYyNSwyNDMwIDYxNjUsMjQzMCIKICAgICAgICAgaWQ9InBvbHlsaW5lNDgiCiAgICAgICAgIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6OHB4O3N0cm9rZS1kYXNoYXJyYXk6NDAsIDQwIiAvPgogICAgICA8IS0tIExpbmUgLS0+CiAgICAgIDxwb2x5bGluZQogICAgICAgICBwb2ludHM9IiAyNTY1LDE4MDAgMjU2NywxNzk5IDI1NzAsMTc5NyAyNTc3LDE3OTQgMjU4OCwxNzg5IDI2MDMsMTc4MiAyNjIzLDE3NzIgMjY0OCwxNzYwICAyNjc5LDE3NDYgMjcxMywxNzMwIDI3NTMsMTcxMiAyNzk1LDE2OTIgMjg0MSwxNjcxIDI4ODksMTY0OSAyOTM5LDE2MjYgMjk5MCwxNjAzICAzMDQxLDE1ODAgMzA5MiwxNTU4IDMxNDIsMTUzNiAzMTkxLDE1MTUgMzIzOSwxNDk0IDMyODYsMTQ3NSAzMzMxLDE0NTYgMzM3NSwxNDM5ICAzNDE3LDE0MjIgMzQ1OCwxNDA3IDM0OTgsMTM5MiAzNTM3LDEzNzggMzU3NSwxMzY1IDM2MTIsMTM1MyAzNjQ5LDEzNDEgMzY4NiwxMzMwICAzNzIyLDEzMTkgMzc1OSwxMzA5IDM3OTUsMTI5OSAzODMzLDEyOTAgMzg2NiwxMjgyIDM5MDAsMTI3NCAzOTM1LDEyNjYgMzk3MCwxMjU5ICA0MDA3LDEyNTIgNDA0NCwxMjQ1IDQwODIsMTIzOCA0MTIyLDEyMzEgNDE2MywxMjI0IDQyMDYsMTIxOCA0MjUwLDEyMTEgNDI5NywxMjA1ICA0MzQ1LDExOTggNDM5NiwxMTkyIDQ0NDgsMTE4NSA0NTAzLDExNzggNDU2MCwxMTcyIDQ2MTksMTE2NSA0NjgwLDExNTggNDc0MiwxMTUyICA0ODA1LDExNDUgNDg2OSwxMTM5IDQ5MzMsMTEzMiA0OTk3LDExMjYgNTA1OSwxMTIwIDUxMjAsMTExNCA1MTc3LDExMDggNTIzMSwxMTAzICA1MjgxLDEwOTkgNTMyNiwxMDk1IDUzNjUsMTA5MSA1Mzk5LDEwODggNTQyNywxMDg2IDU0NDksMTA4NCA1NDY1LDEwODIgNTQ5MCwxMDgwICIKICAgICAgICAgaWQ9InBvbHlsaW5lNTAiCiAgICAgICAgIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MzBweDtzdHJva2UtbGluZWpvaW46YmV2ZWwiIC8+CiAgICAgIDwhLS0gRm9yd2FyZCBhcnJvdyB0byBwb2ludCAwLDAgLS0+CiAgICAgIDxwb2x5Z29uCiAgICAgICAgIHBvaW50cz0iIgogICAgICAgICBzdHJva2UtbWl0ZXJsaW1pdD0iOCIKICAgICAgICAgaWQ9InBvbHlnb241MiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NjBweDtzdHJva2UtbWl0ZXJsaW1pdDo4IiAvPgogICAgICA8IS0tIExpbmUgLS0+CiAgICAgIDxkZWZzCiAgICAgICAgIGlkPSJkZWZzNTciPgogICAgICAgIDxjbGlwUGF0aAogICAgICAgICAgIGlkPSJpZDE6Y3AwIj4KICAgICAgICAgIDxwYXRoCiAgICAgICAgICAgICBkPSJNIDQ4MCwyNDkgSCA2NDIzIFYgMzc2OCBIIDQ4MCBaIG0gMjgwMiwxMjYwIC0yNCwtNTUgLTI0MSwxMTcgMTUsMzMgeiIKICAgICAgICAgICAgIGlkPSJwYXRoNTQiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIiAvPgogICAgICAgIDwvY2xpcFBhdGg+CiAgICAgIDwvZGVmcz4KICAgICAgPHBvbHlsaW5lCiAgICAgICAgIHBvaW50cz0iIDI1NjUsMjE2MCAyNTY3LDIxNjAgMjU3MCwyMTYxIDI1NzgsMjE2MyAyNTg5LDIxNjUgMjYwNSwyMTY4IDI2MjYsMjE3MiAyNjUyLDIxNzggIDI2ODQsMjE4NCAyNzIxLDIxOTEgMjc2MywyMTk5IDI4MDksMjIwOCAyODU5LDIyMTggMjkxMSwyMjI4IDI5NjYsMjIzOCAzMDIyLDIyNDggIDMwNzksMjI1OSAzMTM2LDIyNjkgMzE5MywyMjc5IDMyNDgsMjI4OSAzMzAzLDIyOTggMzM1NSwyMzA3IDM0MDcsMjMxNSAzNDU2LDIzMjIgIDM1MDQsMjMyOSAzNTQ5LDIzMzYgMzU5MywyMzQyIDM2MzYsMjM0NyAzNjc3LDIzNTIgMzcxNywyMzU2IDM3NTUsMjM1OSAzNzkyLDIzNjIgIDM4MjksMjM2NSAzODY1LDIzNjcgMzkwMCwyMzY4IDM5MzUsMjM2OSAzOTcwLDIzNzAgNDAwNSwyMzcwIDQwNDAsMjM3MCA0MDc1LDIzNjkgIDQxMTAsMjM2OCA0MTQ1LDIzNjcgNDE4MSwyMzY1IDQyMTgsMjM2MiA0MjU1LDIzNTkgNDI5MywyMzU2IDQzMzMsMjM1MiA0Mzc0LDIzNDcgIDQ0MTcsMjM0MiA0NDYxLDIzMzYgNDUwNiwyMzI5IDQ1NTQsMjMyMiA0NjAzLDIzMTUgNDY1NSwyMzA3IDQ3MDcsMjI5OCA0NzYyLDIyODkgIDQ4MTcsMjI3OSA0ODc0LDIyNjkgNDkzMSwyMjU5IDQ5ODgsMjI0OCA1MDQ0LDIyMzggNTA5OSwyMjI4IDUxNTEsMjIxOCA1MjAxLDIyMDggIDUyNDcsMjE5OSA1Mjg5LDIxOTEgNTMyNiwyMTg0IDUzNTgsMjE3OCA1Mzg0LDIxNzIgNTQwNSwyMTY4IDU0MjEsMjE2NSA1NDQ1LDIxNjAgIgogICAgICAgICBjbGlwLXBhdGg9InVybCgjaWQxOmNwMCkiCiAgICAgICAgIGlkPSJwb2x5bGluZTU5IgogICAgICAgICBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjMwcHg7c3Ryb2tlLWxpbmVqb2luOmJldmVsIiAvPgogICAgICA8IS0tIEZvcndhcmQgYXJyb3cgdG8gcG9pbnQgMzA0MSwxNTgwIC0tPgogICAgICA8cG9seWdvbgogICAgICAgICBwb2ludHM9IjMyODIsMTUwOSAzMjU4LDE0NTQgMzE2MCwxNTI5ICIKICAgICAgICAgc3Ryb2tlLW1pdGVybGltaXQ9IjgiCiAgICAgICAgIGlkPSJwb2x5Z29uNjEiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjYwcHg7c3Ryb2tlLW1pdGVybGltaXQ6OCIgLz4KICAgICAgPCEtLSBUZXh0IC0tPgogICAgICA8dGV4dAogICAgICAgICB4bWw6c3BhY2U9InByZXNlcnZlIgogICAgICAgICB4PSI0OTUiCiAgICAgICAgIHk9IjcyMCIKICAgICAgICAgZm9udC1zdHlsZT0ibm9ybWFsIgogICAgICAgICBmb250LXdlaWdodD0ibm9ybWFsIgogICAgICAgICBmb250LXNpemU9IjI4OCIKICAgICAgICAgaWQ9InRleHQ2MyIKICAgICAgICAgc3R5bGU9ImZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6Mjg4cHg7Zm9udC1mYW1pbHk6VGltZXM7dGV4dC1hbmNob3I6c3RhcnQ7ZmlsbDojMDAwMDAwIj5QeXRob24gLSBkeW5hbWljIHR5cGluZzwvdGV4dD4KICAgICAgPCEtLSBUZXh0IC0tPgogICAgICA8dGV4dAogICAgICAgICB4bWw6c3BhY2U9InByZXNlcnZlIgogICAgICAgICB4PSI2MzAiCiAgICAgICAgIHk9IjIwNzAiCiAgICAgICAgIGZvbnQtc3R5bGU9Im5vcm1hbCIKICAgICAgICAgZm9udC13ZWlnaHQ9Im5vcm1hbCIKICAgICAgICAgZm9udC1zaXplPSIyNDAiCiAgICAgICAgIGlkPSJ0ZXh0NjUiCiAgICAgICAgIHN0eWxlPSJmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjI0MHB4O2ZvbnQtZmFtaWx5OlRpbWVzO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMCI+dmFyaWFibGVfbmFtZTwvdGV4dD4KICAgICAgPCEtLSBUZXh0IC0tPgogICAgICA8dGV4dAogICAgICAgICB4bWw6c3BhY2U9InByZXNlcnZlIgogICAgICAgICB4PSI1MzEwIgogICAgICAgICB5PSIzNjAiCiAgICAgICAgIGZvbnQtc3R5bGU9Im5vcm1hbCIKICAgICAgICAgZm9udC13ZWlnaHQ9Im5vcm1hbCIKICAgICAgICAgZm9udC1zaXplPSIyNDAiCiAgICAgICAgIGlkPSJ0ZXh0NjciCiAgICAgICAgIHN0eWxlPSJmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjI0MHB4O2ZvbnQtZmFtaWx5OlRpbWVzO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMCI+bWVtb3J5PC90ZXh0PgogICAgICA8IS0tIFRleHQgLS0+CiAgICAgIDx0ZXh0CiAgICAgICAgIHhtbDpzcGFjZT0icHJlc2VydmUiCiAgICAgICAgIHg9IjU3MTUiCiAgICAgICAgIHk9IjIyOTUiCiAgICAgICAgIGZvbnQtc3R5bGU9Im5vcm1hbCIKICAgICAgICAgZm9udC13ZWlnaHQ9Im5vcm1hbCIKICAgICAgICAgZm9udC1zaXplPSIyMTYiCiAgICAgICAgIGlkPSJ0ZXh0NjkiCiAgICAgICAgIHN0eWxlPSJmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjIxNnB4O2ZvbnQtZmFtaWx5OlRpbWVzO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMCI+c3RyPC90ZXh0PgogICAgICA8IS0tIFRleHQgLS0+CiAgICAgIDx0ZXh0CiAgICAgICAgIHhtbDpzcGFjZT0icHJlc2VydmUiCiAgICAgICAgIHg9IjU3NjAiCiAgICAgICAgIHk9IjEyNjAiCiAgICAgICAgIGZvbnQtc3R5bGU9Im5vcm1hbCIKICAgICAgICAgZm9udC13ZWlnaHQ9Im5vcm1hbCIKICAgICAgICAgZm9udC1zaXplPSIyMTYiCiAgICAgICAgIGlkPSJ0ZXh0NzEiCiAgICAgICAgIHN0eWxlPSJmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjIxNnB4O2ZvbnQtZmFtaWx5OlRpbWVzO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMCI+aW50PC90ZXh0PgogICAgPC9nPgogIDwvZz4KPC9zdmc+Cg=="
     ]
    }
   },
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![typing.svg](attachment:typing.svg)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We say that a variable is a name that *refers* to a value or and object, and the assignment operator *binds* a variable name to a value."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The basic data types in Python are: int, float, complex, str (a string), bool (a boolean with values True and False), and bytes. Below are few examples of their use."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Result of the comparison: False\n",
      "Complex multiplication: (-4+0j)\n",
      "concatenation\n"
     ]
    }
   ],
   "source": [
    "i=5\n",
    "f=1.5\n",
    "b = i==4\n",
    "print(\"Result of the comparison:\", b)\n",
    "c=0+2j\n",
    "print(\"Complex multiplication:\", c*c)\n",
    "s=\"conca\" + \"tenation\"\n",
    "print(s)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The names of the types act as conversion operators between types:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-2\n",
      "2.0\n",
      "123\n",
      "True False\n",
      "234\n"
     ]
    }
   ],
   "source": [
    "print(int(-2.8))\n",
    "print(float(2))\n",
    "print(int(\"123\"))\n",
    "print(bool(-2), bool(0))  # Zero is interpreted as False\n",
    "print(str(234))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Creating strings\n",
    "A string is a sequence of characters commonly used to store input or output data in a program. The characters of a string are specified either between single (') or double (\") quotes. This optionaly is useful if a string needs to contain a quotation mark:\n",
    "\"I don't want to go!\". You can also achieve this by *escaping* the quotation mark with the backslash: 'I don\\'t want to go'.\n",
    "\n",
    "The string can also contain other escape sequences like \\n for newline and \\t for a tabulator. See [literals](https://docs.python.org/3/reference/lexical_analysis.html#literals) for a list of all escape sequences."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "One\tTwo\n",
      "Three\tFour\n"
     ]
    }
   ],
   "source": [
    "print(\"One\\tTwo\\nThree\\tFour\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A string containing newlines can be easily given within triple double or triple single quotes:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "s=\"\"\"A string\n",
    "spanning over\n",
    "several lines\"\"\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Although we can concatenate strings using the + operator, for effiency reasons, one should use the join method to concatenate largen number of strings:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "firstsecond\n",
      "first second second first\n"
     ]
    }
   ],
   "source": [
    "a=\"first\"\n",
    "b=\"second\"\n",
    "print(a+b)\n",
    "print(\" \".join([a, b, b, a]))   # More about the join method later\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Sometimes printing by concatenation from pieces can be clumsy:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 plus 3 is equal to 4\n",
      "1 plus 3 is equal to 4\n"
     ]
    }
   ],
   "source": [
    "print(str(1) + \" plus \" + str(3) + \" is equal to \" + str(4))\n",
    "# slightly better\n",
    "print(1, \"plus\", 3, \"is equal to\", 4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The multiple catenation and quotation characters break the flow of thought. *String interpolation* offers somewhat easier syntax:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 plus 3 is equal to 4\n"
     ]
    }
   ],
   "source": [
    "print(\"%i plus %i is equal to %i\" % (1, 3, 4))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Or alternatively using the newer format-method:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 plus 3 is equal to 4\n"
     ]
    }
   ],
   "source": [
    "print(\"{} plus {} is equal to {}\".format(1, 3, 4))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The %i format specifier corresponds to integers and the specifier %f corresponds to floats.\n",
    "It is often useful to specify the number of decimals when printing the float:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.6 1.70 1.800\n",
      "1.6 1.70 1.800\n"
     ]
    }
   ],
   "source": [
    "print(\"%.1f %.2f %.3f\" % (1.6, 1.7, 1.8))               # Old style\n",
    "print(\"{:.1f} {:.2f} {:.3f}\".format(1.6, 1.7, 1.8))     # new style"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Look [here](https://pyformat.info/#number) for more details about format specifiers, and for comparison between the old and new style of string interpolation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Expressions\n",
    "An *expression* is a piece of Python code that results in a value. It consists of values combined together with *operators*. Values can be literals, such as `1`, `1.2`, `\"text\"`, or variables. Operators include arithmetics operators, comparison operators, function call, indexing, attribute references, among others. Below there are a few examples of expressions:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "```1+2\n",
    "7/(2+0.1)\n",
    "a\n",
    "cos(0)\n",
    "mylist[1]\n",
    "c > 0 and c !=1\n",
    "(1,2,3)\n",
    "a<5\n",
    "obj.attr\n",
    "(-1)**2 == 1```"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-warning\">Note that in Python the operator `//` performs integer division and operator `/` performs float division. The `**` operator denotes exponentiation. These operators might therefore behave differently than in many other comman languages.</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As another example the following expression computes the kinetic energy of a non-rotating object:\n",
    "`0.5 * mass * velocity**2`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Statements\n",
    "Statements are command that have some effect. For example, a function call (that is not part of another expression) is a statement. Also, the variable assignment is a statement:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "i = 5\n",
    "i = i+1    # This is a commong idion to increment the value of i by one\n",
    "i += 1     # This is a short-hand for the above"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It turns out that the operators `+ - * / // % & | ^ >> << **` have the corresponding *augmented assignment operators* `+= -= *= /= //= %= &= |= ^= >>= <<= **=`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Another large set of statements if the flow-control statements such as if-else, for and while loops. We will look into these in the next sections."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Loops for repetitive tasks\n",
    "In Python we have two kinds of loops: while and for. We briefly saw the for loop earlier. Let's now look at the while loop. A while loop repeats a set of statements while a given condition holds. An example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Square of 1 is 1\n",
      "Square of 2 is 4\n",
      "Square of 3 is 9\n",
      "Square of 4 is 16\n",
      "Square of 5 is 25\n",
      "Square of 6 is 36\n",
      "Square of 7 is 49\n",
      "Square of 8 is 64\n",
      "Square of 9 is 81\n",
      "Square of 10 is 100\n",
      "Square of 11 is 121\n",
      "Square of 12 is 144\n",
      "Square of 13 is 169\n",
      "Square of 14 is 196\n",
      "Square of 15 is 225\n",
      "Square of 16 is 256\n",
      "Square of 17 is 289\n",
      "Square of 18 is 324\n",
      "Square of 19 is 361\n",
      "Square of 20 is 400\n",
      "Square of 21 is 441\n",
      "Square of 22 is 484\n",
      "Square of 23 is 529\n",
      "Square of 24 is 576\n",
      "Square of 25 is 625\n",
      "Square of 26 is 676\n",
      "Square of 27 is 729\n",
      "Square of 28 is 784\n",
      "Square of 29 is 841\n",
      "Square of 30 is 900\n",
      "Square of 31 is 961\n",
      "Finished printing all the squares below 1000\n"
     ]
    }
   ],
   "source": [
    "i=1\n",
    "while i*i < 1000:\n",
    "    print(\"Square of\", i, \"is\", i*i)\n",
    "    i = i + 1\n",
    "print(\"Finished printing all the squares below 1000.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note again that the body of the while statement was marked with the indentation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Another way of repeating statements is with the for statement. An example"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The sum is 45\n"
     ]
    }
   ],
   "source": [
    "sum=0\n",
    "for i in [0,1,2,3,4,5,6,7,8,9]:\n",
    "    sum = sum + i\n",
    "print(\"The sum is\", sum)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The for loop executes the statements in the block as many times as there are elements in the given list. At each iteration the variable i refers to another value from the list in order. Instead of the giving the list explicitly as above, we could have used the *generator* range(10) which returns values from the sequence 0,1,...,9 as the for loop asks for a new value. In the most general form the for loop goes through all the elements in an *iterable*.\n",
    "Besides lists and generators there are other iterables. We will talk about iterables and generators later this week."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When one wants to iterate through all the elements in an iterable, then the for loop is a natural choice. But sometimes while loops offer cleaner solution. For instance, if we want\n",
    "to go through all Fibonacci number up till a given limit, then it is easier to do with a `while` loop."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Decision making with the if statement\n",
    "The if-else statement works as can be expected.\n",
    "Try running the below cell by pressing control+enter."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Give an integer: -2\n",
      "The absolute value of -2 is 2\n"
     ]
    }
   ],
   "source": [
    "x=input(\"Give an integer: \")\n",
    "x=int(x)\n",
    "if x >= 0:\n",
    "    a=x\n",
    "else:\n",
    "    a=-x\n",
    "print(\"The absolute value of %i is %i\" % (x, a))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The general from of an if-else statement is\n",
    "\n",
    "```if condition1:\n",
    "    statement1_1\n",
    "    statement1_2\n",
    "    ...\n",
    "elif condition2:\n",
    "    statement2_1\n",
    "    statement2_2\n",
    "    ...\n",
    "...\n",
    "else:\n",
    "    statementn_1\n",
    "    statementn_2\n",
    "    ...\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Another example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Give a number: -1\n",
      "c is negative\n"
     ]
    }
   ],
   "source": [
    "c=float(input(\"Give a number: \"))\n",
    "if c > 0:\n",
    "    print(\"c is positive\")\n",
    "elif c<0:\n",
    "    print(\"c is negative\")\n",
    "else:\n",
    "    print(\"c is zero\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Breaking and continuing loop\n",
    "Breaking the loop, when the wanted element is found, with the `break` statement:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The first negative list element was -1\n"
     ]
    }
   ],
   "source": [
    "l=[1,3,65,3,-1,56,-10]\n",
    "for x in l:\n",
    "    if x < 0:\n",
    "        break\n",
    "print(\"The first negative list element was\", x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Stopping current iteration and continuing to the next one with the `continue` statement:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Square root of 1 is 1.000000\n",
      "Natural logarithm of 1 is 0.000000\n",
      "Square root of 3 is 1.732051\n",
      "Natural logarithm of 3 is 1.098612\n",
      "Square root of 65 is 8.062258\n",
      "Natural logarithm of 65 is 4.174387\n",
      "Square root of 3 is 1.732051\n",
      "Natural logarithm of 3 is 1.098612\n",
      "Square root of 56 is 7.483315\n",
      "Natural logarithm of 56 is 4.025352\n"
     ]
    }
   ],
   "source": [
    "from math import sqrt, log\n",
    "l=[1,3,65,3,-1,56,-10]\n",
    "for x in l:\n",
    "    if x < 0:\n",
    "        continue\n",
    "    print(\"Square root of %i is %f\" % (x, sqrt(x)))\n",
    "    print(\"Natural logarithm of %i is %f\" % (x, log(x)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Functions\n",
    "A function is defined with the `def` statement. Let's do a doubling function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "8 2.4 abcabc\n"
     ]
    }
   ],
   "source": [
    "def double(x):\n",
    "    \"This function multiplies its argument by two.\"\n",
    "    return x*2\n",
    "print(double(4), double(1.2), double(\"abc\")) # It even happens to work for strings!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The double function takes only one parameter. Notice the *docstring* on the second line. It documents the purpose and usage of the function. Let's try to access it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The docstring is: This function multiplies its argument by two.\n",
      "Help on function double in module __main__:\n",
      "\n",
      "double(x)\n",
      "    This function multiplies its argument by two.\n",
      "\n"
     ]
    }
   ],
   "source": [
    "print(\"The docstring is:\", double.__doc__)\n",
    "help(double)   # Another way to access the docstring"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Most of Python's builtin functions, classes, and modules should contain a docstring."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on built-in function print in module builtins:\n",
      "\n",
      "print(...)\n",
      "    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n",
      "    \n",
      "    Prints the values to a stream, or to sys.stdout by default.\n",
      "    Optional keyword arguments:\n",
      "    file:  a file-like object (stream); defaults to the current sys.stdout.\n",
      "    sep:   string inserted between values, default a space.\n",
      "    end:   string appended after the last value, default a newline.\n",
      "    flush: whether to forcibly flush the stream.\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(print)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "25\n"
     ]
    }
   ],
   "source": [
    "def sum_of_squares(a, b):\n",
    "    \"Computes the sum of arguments squared\"\n",
    "    return a**2 + b**2\n",
    "print(sum_of_squares(3, 4))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It would be nice that the number of arguments could be arbitrary, not just two. We could pass a list to the function as a parameter."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "4\n",
      "45\n"
     ]
    }
   ],
   "source": [
    "def sum_of_squares(lst):\n",
    "    \"Computes the sum of squares of elements in the list given as parameter\"\n",
    "    sum=0\n",
    "    for x in lst:\n",
    "        sum += x**2\n",
    "    return sum\n",
    "print(sum_of_squares([-2]))\n",
    "print(sum_of_squares([-2,4,5]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This works perfectly! There is however some extra typing with the brackets around the lists. Let's see if we can do better:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "4\n",
      "45\n"
     ]
    }
   ],
   "source": [
    "def sum_of_squares(*t):\n",
    "    \"Computes the sum of squares of arbitrary number of arguments\"\n",
    "    sum=0\n",
    "    for x in t:\n",
    "        sum += x**2\n",
    "    return sum\n",
    "print(sum_of_squares(-2))\n",
    "print(sum_of_squares(-2,4,5))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The strange looking argument notation is called *argument packing*. It packs all the given positional arguments into a tuple `t`. We will encounter tuples again later, but it suffices now to say that tuples are immutable lists. With the for loop we can iterate through all the elements in the tuple.\n",
    "\n",
    "Conversely, there is also syntax for *argument unpacking*. It has confusingly exactly same notation as argument packing, but they are separated by the location where used. Packing happens in the parameter list of the functions definition, and unpacking happens where the function is called:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "With list unpacked as arguments to the functions: 90\n"
     ]
    },
    {
     "ename": "TypeError",
     "evalue": "unsupported operand type(s) for ** or pow(): 'list' and 'int'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-77-4203ff5c9ea6>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0mlst\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m5\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m8\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"With list unpacked as arguments to the functions:\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msum_of_squares\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mlst\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 3\u001b[0;31m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msum_of_squares\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlst\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m    \u001b[0;31m# Does not work correctly\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m<ipython-input-74-b89e2f7c723d>\u001b[0m in \u001b[0;36msum_of_squares\u001b[0;34m(*t)\u001b[0m\n\u001b[1;32m      3\u001b[0m     \u001b[0msum\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m     \u001b[0;32mfor\u001b[0m \u001b[0mx\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mt\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 5\u001b[0;31m         \u001b[0msum\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m**\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      6\u001b[0m     \u001b[0;32mreturn\u001b[0m \u001b[0msum\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      7\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msum_of_squares\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m-\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mTypeError\u001b[0m: unsupported operand type(s) for ** or pow(): 'list' and 'int'"
     ]
    }
   ],
   "source": [
    "lst=[1,5,8]\n",
    "print(\"With list unpacked as arguments to the functions:\", sum_of_squares(*lst))\n",
    "print(sum_of_squares(lst))    # Does not work correctly"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The second call failed because the function tried to raise the list of numbers to the second power. Inside the function body we have t=([1,5,8]), where the parentheses denote a tuple with one element, a list."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In addition to positional parameters we have seen so far, a function can also have *named parameters*. An example will explain this concept best:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "One can also specify optional parameter by giving the parameters a default value. The parameters that have default values must come after those parameters that don't. We saw that the parameters of the print function were of form `print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)`. There were four parameters with default values. If some default values don't suit us, we give them in the function call using the name of the parameter:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 -*- 2 -*- 3 |first -*- second -*- third |"
     ]
    }
   ],
   "source": [
    "print(1, 2, 3, end=' |', sep=' -*- ')\n",
    "print(\"first\", \"second\", \"third\", end=' |', sep=' -*- ')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that the named arguments didn't need to be in the same order as in the function definition. Nor did we need to specify all the parameters with default values, only those we wanted to change."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "5.0\n",
      "4.497941445275415\n"
     ]
    }
   ],
   "source": [
    "def length(*t, degree=2):\n",
    "    \"\"\"Computes the length of the vector given as parameter. By default, it computes\n",
    "    the Euclidean distance (degree==2)\"\"\"\n",
    "    sum=0\n",
    "    for x in t:\n",
    "        sum += abs(x)**degree\n",
    "    return sum**(1/degree)\n",
    "print(length(-4,3))\n",
    "print(length(-4,3, degree=3))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "With the default parameter this is the Euclidean distance, and if $p\\ne 2$ it is called [$p$-norm](https://en.wikipedia.org/wiki/P-norm)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We saw that it was possible to use packing and unpacking of arguments with the * notation, when one wants to specify arbitrary number of *positional arguments*. This is also possible for arbitrary number of named arguments with the `**` notation. We will talk about this more in the data structures section."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
