{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Numpy\n",
    "\n",
    "NumPy is a Python library for handling multi-dimensional arrays. It contains both the data structures needed for the storing and accessing arrays, and operations and functions for computation using these arrays. Although the arrays are usually used for storing number, other type of data can be stored as well, such as strings. Unlike lists in core Python, NumPy's fundamental data structure, the array, must have the same data type for all its elements. The homogeneity of arrays allows highly optimized functions that use arrays as their inputs.\n",
    "\n",
    "There are several uses for high-dimensional arrays in data analysis. For instance, they can be used to:\n",
    "\n",
    "* store matrices, solve systems of linear equations, find eigenvalues/vectors, find matrix decompositions, and solve other problems familiar from linear algebra\n",
    "* store multi-dimensional measurement data. For example, an element a_ij in a 2-dimensional array might store the temperature measured at coordinates i, j on a 2-dimension surface.\n",
    "* images and videos can be represented as NumPy arrays:\n",
    "\n",
    "  * a gray-scale image can be represented as a two dimensional array\n",
    "  * a color image can be represented as a three dimensional image, the third dimension contains the color components red, green, and blue\n",
    "  * a color video can be represented as a four dimensional array\n",
    "* a 2-dimensional table might store a sequence of *samples*, and each sample might be divided into *features*. For example, we could measure the weather conditions once per day, and the conditions could include the temperature, direction and speed of wind, and the amount of rain. Then we would have one sample per day, and the features would be the temperature, wind, and rain. In the standard representation of this kind of tabular data, we the rows corresponds to samples and the columns correspond to features. We see more of this kind of data in the chapters on Pandas and Scikit-learn.\n",
    "\n",
    "In this chapter we will go through:\n",
    "\n",
    "* Creation of arrays\n",
    "* Array types and attributes\n",
    "* Accessing arrays with indexing and slicing\n",
    "* Reshaping of arrays\n",
    "* Combining and splitting arrays\n",
    "* Fast operations on arrays\n",
    "* Aggregations of arrays\n",
    "* Rules of binary array operations\n",
    "* Matrix operations familiar from linear algebra"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We start by importing the NumPy library, and we use the standard abbreviation `np` for it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Creation of arrays\n",
    "There are several ways of creating numpy arrays. One way is to give a (nested) list as a parameter to the `array` constructor:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1, 2, 3])"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.array([1,2,3])   # one dimensional array"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that leaving out the brackets from the above expression, i.e. calling `np.array(1,2,3)` will result in an error."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Two dimensional array can be given by listing the rows of the array:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1, 2, 3],\n",
       "       [4, 5, 6]])"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.array([[1,2,3], [4,5,6]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Similarly, three dimensional array can be described as a list of lists of lists:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[[1, 2],\n",
       "        [3, 4]],\n",
       "\n",
       "       [[5, 6],\n",
       "        [7, 8]]])"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.array([[[1,2], [3,4]], [[5,6], [7,8]]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There are some helper functions to create common types of arrays:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0., 0., 0., 0.],\n",
       "       [0., 0., 0., 0.],\n",
       "       [0., 0., 0., 0.]])"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.zeros((3,4))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To specify that elements are ints instead of float, use the parameter dtype:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0, 0, 0, 0],\n",
       "       [0, 0, 0, 0],\n",
       "       [0, 0, 0, 0]])"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.zeros((3,4), dtype=int)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Similarly `ones` initializes all elements to one, `full` initializes all elements to a specified value, and `empty` leaves the elements uninitialized:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1., 1., 1.],\n",
       "       [1., 1., 1.]])"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.ones((2,3))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[7, 7, 7],\n",
       "       [7, 7, 7]])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.full((2,3), fill_value=7)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[6.90170349e-310, 4.66312875e-310, 0.00000000e+000,\n",
       "        0.00000000e+000],\n",
       "       [2.37151510e-322, 5.53353523e-322, 0.00000000e+000,\n",
       "        3.16202013e-322]])"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.empty((2,4))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `eye` function creates the identity matrix, that is, a matrix with elements on the diagonal are set to one, and non-diagonal elements are set to zero:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1, 0, 0, 0, 0],\n",
       "       [0, 1, 0, 0, 0],\n",
       "       [0, 0, 1, 0, 0],\n",
       "       [0, 0, 0, 1, 0],\n",
       "       [0, 0, 0, 0, 1]])"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.eye(5, dtype=int)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `arange` function works like the `range` function, but produces an array instead of a list."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0, 2, 4, 6, 8])"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.arange(0,10,2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For non-integer ranges it is better to use `linspace`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.        , 0.78539816, 1.57079633, 2.35619449, 3.14159265])"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.linspace(0, np.pi, 5)  # Evenly spaced range with 5 elements"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "With `linspace` one does not have compute the length of the step, but instead one specifies the wanted number of elements. By default, the endpoint is included in the result, unlike with `arange`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Arrays with random elements\n",
    "\n",
    "To test our programs we might use real data as input. However, real data is not always available, and it may take time to gather. We could instead generate random numbers to use as substitute. They can be generated really easily with NumPy, and can be sampled from several different distribution, of which we mention below only a few. Random data can simulate real data better than, for example, ranges or constant arrays. Sometimes we also need random numbers in our programs to choose a subset of real data. NumPy can easily produces arrays of wanted shape filled with random numbers. Below are few examples."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0.886096  , 0.55756628, 0.6478361 , 0.54100462],\n",
       "       [0.91835784, 0.76684297, 0.27486936, 0.5155221 ],\n",
       "       [0.22480377, 0.44763123, 0.43477361, 0.79683321]])"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.random.random((3,4))          # Elements are uniformly distributed from half-open interval [0.0,1.0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 0.9382291 , -0.93755962,  0.90853183, -0.5239464 ],\n",
       "       [-1.09882169, -0.82543964,  2.26272302,  0.55225504],\n",
       "       [-0.23552639,  1.47078892, -0.80461278,  0.17321221]])"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.random.normal(0, 1, (3,4))    # Elements are normally distributed with mean 0 and standard deviation 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 8,  2, -1,  1],\n",
       "       [ 6,  3,  2,  7],\n",
       "       [ 4,  8,  8, -1]])"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.random.randint(-2, 10, (3,4))  # Elements are uniformly distributed integers from the half-open interval [-2,10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Sometimes it is useful to be able to recreate exactly the same data in every run of our program. For example, if there is a bug in our program, which manifests itself only with certain input, then to debug our program it needs to behave deterministically. We can create random numbers deterministically, if we always start from the same starting point. This starting point is usually an integer, and we call it a *seed*. Example of use:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[44 47 64 67 67  9 83 21 36 87]\n",
      "[ 1.26611853 -0.50587654  2.54520078  1.08081191  0.48431215  0.57914048\n",
      " -0.18158257  1.41020463 -0.37447169  0.27519832]\n"
     ]
    }
   ],
   "source": [
    "np.random.seed(0)\n",
    "print(np.random.randint(0, 100, 10))\n",
    "print(np.random.normal(0, 1, 10))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you run the above cell multiple times, it will always give the same number, unlike the earlier examples. Try rerunning them now!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The call to `np.random.seed` initializes the *global* random number generator. The calls `np.random.random`, `np.random.normal`, etc all use this global random number generator. It is however possible to generate new random number generators, and use those to sample random numbers from a distribution. Example on usage:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([66, 92, 98, 17, 83, 57, 86, 97, 96, 47])"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "new_generator = np.random.RandomState(seed=123)  # RandomState is a class, so we give the seed to its constructor\n",
    "new_generator.randint(0, 100, 10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You will see these used later in the materials and in the exercises, just so we can agree what the random input data is. How else could we agree whether result is correct or not, if we can't agree what the input is!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Array types and attributes\n",
    "\n",
    "An array has several attributes: ndim tells the number of dimensions, shape tells the size in each dimension, size tells the number of elements, and dtype tells the element type. Let's create a helper function to explore these attributes:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "def info(name, a):\n",
    "    print(\"%s has dim %i, shape %s, size %i, and dtype %s:\" % (name, a.ndim, a.shape, a.size, a.dtype))\n",
    "    print(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "b has dim 2, shape (2, 3), size 6, and dtype int64:\n",
      "[[1 2 3]\n",
      " [4 5 6]]\n"
     ]
    }
   ],
   "source": [
    "b=np.array([[1,2,3], [4,5,6]])\n",
    "info(\"b\", b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "c has dim 3, shape (2, 2, 3), size 12, and dtype int64:\n",
      "[[[1 2 3]\n",
      "  [4 5 6]]\n",
      "\n",
      " [[1 2 3]\n",
      "  [4 5 6]]]\n"
     ]
    }
   ],
   "source": [
    "c=np.array([b, b])          # Creates a 3-dimensional array\n",
    "info(\"c\", c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "d has dim 2, shape (1, 4), size 4, and dtype int64:\n",
      "[[1 2 3 4]]\n"
     ]
    }
   ],
   "source": [
    "d=np.array([[1,2,3,4]])                # a row vector\n",
    "info(\"d\", d)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note above how Python printed the three dimensional array. The general rules of printing an n-dimensional array as a nested list are:\n",
    "* the last dimension is printed from left to right,\n",
    "* the second-to-last is printed from top to bottom,\n",
    "* the rest are also printed from top to bottom, with each slice separated from the next by an empty line."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Indexing, slicing and reshaping"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Indexing\n",
    "One dimensional array behaves like the list in Python:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "4\n",
      "9\n"
     ]
    }
   ],
   "source": [
    "a=np.array([1,4,2,7,9,5])\n",
    "print(a[1])\n",
    "print(a[-2])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For multi-dimensional array the index is a comma separated tuple instead of a single integer:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 2 3]\n",
      " [4 5 6]]\n",
      "6\n",
      "3\n"
     ]
    }
   ],
   "source": [
    "b=np.array([[1,2,3], [4,5,6]])\n",
    "print(b)\n",
    "print(b[1,2])    # row index 1, column index 2\n",
    "print(b[0,-1])   # row index 0, column index -1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[10  2  3]\n",
      " [ 4  5  6]]\n"
     ]
    }
   ],
   "source": [
    "# As with lists modification through indexing is possible\n",
    "b[0,0] = 10\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that if you give only a single index to a multi-dimensional array, it indexes the first dimension of the array, that is then rows. For example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[10  2  3]\n",
      "[4 5 6]\n"
     ]
    }
   ],
   "source": [
    "print(b[0])    # First row\n",
    "print(b[1])    # Second row"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Slicing\n",
    "Slicing works similarly to lists, but now we can have slice in different dimensions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1 4 2 7 9 5]\n",
      "[4 2]\n",
      "[5 9 7 2 4 1]\n"
     ]
    }
   ],
   "source": [
    "print(a)\n",
    "print(a[1:3])\n",
    "print(a[::-1])    # Reverses the array"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[10  2  3]\n",
      " [ 4  5  6]]\n",
      "[10  4]\n",
      "[10  2  3]\n",
      "[[2 3]\n",
      " [5 6]]\n"
     ]
    }
   ],
   "source": [
    "print(b)\n",
    "print(b[:,0])\n",
    "print(b[0,:])\n",
    "print(b[:,1:])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can even assign to a slice:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[10  7  7]\n",
      " [ 4  7  7]]\n"
     ]
    }
   ],
   "source": [
    "b[:,1:] = 7\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A common idiom is to extract rows or columns from an array:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[10  4]\n",
      "[4 7 7]\n"
     ]
    }
   ],
   "source": [
    "print(b[:,0])    # First column\n",
    "print(b[1,:])    # Second row"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Reshaping\n",
    "\n",
    "When an array is reshaped, its number of elements stays the same, but they are reinterpreted to have a different shape. An example of this is to interpret a one dimensional array as two dimension array:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "anew has dim 2, shape (3, 3), size 9, and dtype int64:\n",
      "[[0 1 2]\n",
      " [3 4 5]\n",
      " [6 7 8]]\n",
      "a has dim 1, shape (9,), size 9, and dtype int64:\n",
      "[0 1 2 3 4 5 6 7 8]\n"
     ]
    }
   ],
   "source": [
    "a=np.arange(9)\n",
    "anew=a.reshape(3,3)\n",
    "info(\"anew\", anew)\n",
    "info(\"a\", a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "d has dim 1, shape (4,), size 4, and dtype int64:\n",
      "[0 1 2 3]\n",
      "dr has dim 2, shape (1, 4), size 4, and dtype int64:\n",
      "[[0 1 2 3]]\n",
      "dc has dim 2, shape (4, 1), size 4, and dtype int64:\n",
      "[[0]\n",
      " [1]\n",
      " [2]\n",
      " [3]]\n"
     ]
    }
   ],
   "source": [
    "d=np.arange(4)             # 1d array\n",
    "dr=d.reshape(1,4)          # row vector\n",
    "dc=d.reshape(4,1)          # column vector\n",
    "info(\"d\", d)\n",
    "info(\"dr\", dr)\n",
    "info(\"dc\", dc)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-warning\">\n",
    "Note the 1d array and the row and column vectors, which are 2d arrays, are fundamentally different objects, even though they look similar. They behave differently when we combine or otherwise operate arrays of different shapes, as we shall see in the next section and later in this material.\n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "An alternative syntax to create, for example, column or row vectors is through the `np.newaxis` keyword. Sometimes this is more easier or natural than with the reshape method:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "d has dim 1, shape (4,), size 4, and dtype int64:\n",
      "[0 1 2 3]\n",
      "drow has dim 2, shape (4, 1), size 4, and dtype int64:\n",
      "[[0]\n",
      " [1]\n",
      " [2]\n",
      " [3]]\n",
      "drow has dim 2, shape (1, 4), size 4, and dtype int64:\n",
      "[[0 1 2 3]]\n",
      "dcol has dim 2, shape (4, 1), size 4, and dtype int64:\n",
      "[[0]\n",
      " [1]\n",
      " [2]\n",
      " [3]]\n"
     ]
    }
   ],
   "source": [
    "info(\"d\", d)\n",
    "info(\"drow\", d[:, np.newaxis])\n",
    "info(\"drow\", d[np.newaxis, :])\n",
    "info(\"dcol\", d[:, np.newaxis])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### a list as an index returns a 2d array, single index a 1d array"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (rows and columns)</div>\n",
    "\n",
    "Write two functions, `get_rows` and `get_columns`, that get a two dimensional array as parameter.\n",
    "They should return the list of rows and columns of the array, respectively. The rows and columns should be one dimensional arrays. You may use the *transpose* operation, which flips rows to columns, in your solution. The transpose is done by the `T` method:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0 1 9 9]\n",
      " [0 4 7 3]\n",
      " [2 7 2 0]\n",
      " [0 4 5 5]]\n",
      "[[0 0 2 0]\n",
      " [1 4 7 4]\n",
      " [9 7 2 5]\n",
      " [9 3 0 5]]\n"
     ]
    }
   ],
   "source": [
    "a=np.random.randint(0, 10, (4,4))\n",
    "print(a)\n",
    "print(a.T)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Test your solution in the main function.\n",
    "Example of usage:\n",
    "```\n",
    "a = np.array([[5, 0, 3, 3],\n",
    " [7, 9, 3, 5],\n",
    " [2, 4, 7, 6],\n",
    " [8, 8, 1, 6]])\n",
    "get_rows(a)\n",
    "[array([5, 0, 3, 3]), array([7, 9, 3, 5]), array([2, 4, 7, 6]), array([8, 8, 1, 6])]\n",
    "get_columns(a)\n",
    "[array([5, 7, 2, 8]), array([0, 9, 4, 8]), array([3, 3, 7, 1]), array([3, 5, 6, 6])]\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Array concatenation, splitting and stacking\n",
    "\n",
    "The are two ways of combining several arrays into one bigger array: `concatenate` and `stack`. `Concatenate` takes n-dimensional arrays and returns an n-dimensional array, whereas `stack` takes n-dimensional arrays and returns n+1-dimensional array. Few examples of these:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a has shape (2,): [0 1]\n",
      "b has shape (3,): [2 3 4]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([0, 1, 2, 3, 4])"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a=np.arange(2)\n",
    "b=np.arange(2,5)\n",
    "print(\"a has shape %s: %s\" % (a.shape, a))\n",
    "print(\"b has shape %s: %s\" % (b.shape, b))\n",
    "np.concatenate((a,b))  # concatenating 1d arrays"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "c has shape (2, 2):\n",
      "[[1 2]\n",
      " [3 4]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([[1, 2],\n",
       "       [3, 4],\n",
       "       [1, 2],\n",
       "       [3, 4]])"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "c=np.arange(1,5).reshape(2,2)\n",
    "print(\"c has shape %s:\" % (c.shape,), c, sep=\"\\n\")\n",
    "np.concatenate((c,c))   # concatenating 2d arrays"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "By default `concatenate` joins the arrays along axis 0. To join the arrays horizontally, add parameter `axis=1`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1, 2, 1, 2],\n",
       "       [3, 4, 3, 4]])"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.concatenate((c,c), axis=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you want to catenate arrays with different dimensions, for example to add a new column to a 2d array, you must first  reshape the arrays to have same number of dimensions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "New row:\n",
      "[[1 2]\n",
      " [3 4]\n",
      " [0 1]]\n",
      "New column:\n",
      "[[1 2 0]\n",
      " [3 4 1]]\n"
     ]
    }
   ],
   "source": [
    "print(\"New row:\")\n",
    "print(np.concatenate((c,a.reshape(1,2))))\n",
    "print(\"New column:\")\n",
    "print(np.concatenate((c,a.reshape(2,1)), axis=1))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Using `stack` to create higher dimensional arrays from lower dimensional arrays:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[2, 3, 4],\n",
       "       [2, 3, 4]])"
      ]
     },
     "execution_count": 38,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.stack((b,b))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[2, 2],\n",
       "       [3, 3],\n",
       "       [4, 4]])"
      ]
     },
     "execution_count": 39,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.stack((b,b), axis=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Inverse operation of `concatenate` is `split`. Its argument specifies either the number of equal parts the array is divided into, or it specifies explicitly the break points."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "d:\n",
      "[[ 0  1]\n",
      " [ 2  3]\n",
      " [ 4  5]\n",
      " [ 6  7]\n",
      " [ 8  9]\n",
      " [10 11]]\n",
      "d1:\n",
      "[[0 1]\n",
      " [2 3]\n",
      " [4 5]]\n",
      "d2:\n",
      "[[ 6  7]\n",
      " [ 8  9]\n",
      " [10 11]]\n"
     ]
    }
   ],
   "source": [
    "d=np.arange(12).reshape(6,2)\n",
    "print(\"d:\")\n",
    "print(d)\n",
    "d1,d2 = np.split(d, 2)\n",
    "print(\"d1:\")\n",
    "print(d1)\n",
    "print(\"d2:\")\n",
    "print(d2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "d:\n",
      "[[ 0  1  2  3  4  5]\n",
      " [ 6  7  8  9 10 11]]\n",
      "part 0:\n",
      "[[0 1]\n",
      " [6 7]]\n",
      "part 1:\n",
      "[[2]\n",
      " [8]]\n",
      "part 2:\n",
      "[[ 3  4]\n",
      " [ 9 10]]\n",
      "part 3:\n",
      "[[ 5]\n",
      " [11]]\n"
     ]
    }
   ],
   "source": [
    "d=np.arange(12).reshape(2,6)\n",
    "print(\"d:\")\n",
    "print(d)\n",
    "parts=np.split(d, (2,3,5), axis=1)\n",
    "for i, p in enumerate(parts):\n",
    "    print(\"part %i:\" % i)\n",
    "    print(p)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (row and column vectors)</div>\n",
    "\n",
    "Create function `get_row_vectors` that returns a list of rows from the input array of shape `(n,m)`, but this time the rows must have shape `(1,n)`. Similarly, create function `get_columns_vectors` that returns the column of the input matrix having shape `(m,1)`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (diamond)</div>\n",
    "Create a function `diamond` that returns a two dimensional integer array where the `1`s form a diamond shape. Rest of the numbers are `0`. The function should get a parameter that tells the length of a side of the diamond. Do this using the `eye` and `concatenate` functions of NumPy and array slicing.\n",
    "\n",
    "Example of usage:\n",
    "```\n",
    "print(diamond(3))\n",
    "[[0 0 1 0 0]\n",
    " [0 1 0 1 0]\n",
    " [1 0 0 0 1]\n",
    " [0 1 0 1 0]\n",
    " [0 0 1 0 0]]\n",
    "print(diamond(1))\n",
    "[[1]]\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Fast computation using universal functions\n",
    "\n",
    "In addition to providing a way to store and access multi-dimension arrays, NumPy also provides several routines to perform computations on them. One of the reasons for the popularity of NumPy is that these computations can be very efficient, much more efficient than what Python can normally do. The biggest bottle-necks in efficiency are the loops, which can be iterated millions, billions, or even more times. The loops should be as efficient as possible. What slows down loops in Python as the fact that Python is dynamically typed language. That means that at each expression Python has find out which are the typed of the arguments of the operations. Let's consider the following loop:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1, 5.2, 'ab']\n"
     ]
    }
   ],
   "source": [
    "L=[1, 5.2, \"ab\"]\n",
    "L2=[]\n",
    "for x in L:\n",
    "    L2.append(x*2)\n",
    "print(L)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "At each iteration of this loop Python has find out the type of the variable x, which can in this example be an int, a float or a string, and depending on this type call a different function to perform the \"multiplication\" by two. What makes NumPy efficient, is the requirement that each element in an array must be of the same type. This homogeneity of arrays makes it possible to create *vectorized* operation, which don't operate on single elements, but on arrays (or subarrays). The previous example using vectorized operations of NumPy is shown below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 4.2 10.  34.4]\n"
     ]
    }
   ],
   "source": [
    "a=np.array([2.1, 5.0, 17.2])\n",
    "a2=a*2\n",
    "print(a2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Because each iteration is using identical operations only the data differs, this can compiled into machine language, and then performed in one go, hence avoiding Python's dynamic typing. The name vector operation comes from linear algebra where the addition of two vectors \\\\(v=(v_1,v_2, \\ldots, v_d)\\\\) and  \\\\(w=(w_1,w_2, \\ldots, w_d)\\\\) is defined element-wise as \\\\(v+w = (v_1 + w_1,v_2 + w_2, \\ldots, v_d + w_d)\\\\).\n",
    "\n",
    "In addition to addition they are several mathematical functions defined in the vector form. The basic arithmetic operations are: addition `+`, subtraction `-`, negation `-`, multiplication `*`, division `/`, floor division `//`, exponentation `**`, and remainder `%`. \n",
    "\n",
    "The can be combined into more complicated expressions. An example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[   4.41   -80.    -710.016]\n"
     ]
    }
   ],
   "source": [
    "b=np.array([-1, 3.2, 2.4])\n",
    "print(-a**2 * b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Several other mathematical functions are defined as well. A few examples of these can be found below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1.  3.2 2.4]\n",
      "[ 0.54030231 -0.99829478 -0.73739372]\n",
      "[ 0.36787944 24.5325302  11.02317638]\n",
      "[0.         1.67807191 1.26303441]\n"
     ]
    }
   ],
   "source": [
    "print(np.abs(b))\n",
    "print(np.cos(b))\n",
    "print(np.exp(b))\n",
    "print(np.log2(np.abs(b)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In NumPy nomenclature these vector operations are called *ufuncs* (universal functions)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Aggregations: max, min, sum, mean, standard deviation...\n",
    "\n",
    "Aggregations allow us to condense the information in an array into just few numbers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 72 -53  17  92 -33]\n",
      " [ 95   3 -91 -79 -64]\n",
      " [-13 -30 -12  40 -42]\n",
      " [ 93 -61 -13  74 -12]]\n",
      "Minimum: -91, maximum: 95\n",
      "Sum: -17\n",
      "Mean: -0.850000, standard deviation: 58.398866\n"
     ]
    }
   ],
   "source": [
    "np.random.seed(0)\n",
    "a=np.random.randint(-100, 100, (4,5))\n",
    "print(a)\n",
    "print(\"Minimum: %i, maximum: %i\" %(a.min(), a.max()))\n",
    "print(\"Sum: %i\" % a.sum())\n",
    "print(\"Mean: %f, standard deviation: %f\" % (a.mean(), a.std()))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Instead of aggregating over the whole array, we can aggregate over certain axes only as well:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 5 9 8 9]\n",
      " [4 3 0 3 5]\n",
      " [0 2 3 8 1]\n",
      " [3 3 3 7 0]]\n",
      "Column sums: [ 8 13 15 26 15]\n",
      "Row sums: [32 15 14 16]\n"
     ]
    }
   ],
   "source": [
    "b=np.random.randint(0, 10, (4,5))\n",
    "print(b)\n",
    "print(\"Column sums:\", b.sum(axis=0))\n",
    "print(\"Row sums:\", b.sum(axis=1))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "NUOLIKUVAT SUUNNISTA TÄHÄN"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-warning\">\n",
    "Note that most of the aggregation functions in NumPy have the corresponding method. In addition, Python language has builtin functions `sum`, `min`, `max`, `any`, and `all` for sequences. Make sure you don't accidentally use these for arrays, since they may have slightly different semantics, and they will be significantly slower than NumPy's functions and methods.\n",
    "</div>\n",
    "\n",
    "Python function | NumPy function | NumPy method\n",
    "-------|----------------|-------------\n",
    "sum    | np.sum         | a.sum\n",
    " -     | np.prod        | a.prod\n",
    " -     | np.mean        | a.mean\n",
    " -     | np.std         | a.std\n",
    " -     | np.var         | a.var\n",
    " min   | np.min         | a.min\n",
    " max   | np.max         | a.max\n",
    " -     | np.argmin      | a.argmin\n",
    " -     | np.argmax      | a.argmax\n",
    " -     | np.median      | -\n",
    " -     | np.percentile  | -\n",
    " any   | np.any         | a.any\n",
    " all   | np.all         | a.all\n",
    " \n",
    " "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's measure how much slower Python's sum function is compared to Numpy's equivalent when aggrating over an array:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2.67 µs ± 70 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n"
     ]
    }
   ],
   "source": [
    "a=np.arange(1000)\n",
    "%timeit np.sum(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "72.9 µs ± 5.06 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit sum(a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The speed of NumPy is partly due to the fact that its arrays must have same type for all the elements. This requirement allows some efficient optimizations."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (vector lengths)</div>\n",
    "\n",
    "Write function `vector_lengths` that gets a two dimensional array of shape (n,m) as a parameter. Each row in this array corresponds to a vector. The function should return an array of shape (n,), that has the length of each vector in the input. The length is defined by the usual \n",
    "[Euclidean norm](<https://en.wikipedia.org/wiki/Norm_(mathematics&#41;#Euclidean_norm>). Don't use loops at all in your solution. Instead use vectorized operations. You must use at least the `np.sum` and the `np.sqrt` functions. You can't use the function `scipy.linalg.norm`. Test your function in the main function."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (vector angles)</div>\n",
    "\n",
    "Let x and y be m-dimensional vectors. The angle $\\alpha$ between two vectors is defined by the equation\n",
    "$\\cos_{xy}(\\alpha):=\\frac{\\langle x,y\\rangle}{||x|| ||y||}$,\n",
    "where the angle brackets denote the [inner product](https://en.wikipedia.org/wiki/Inner_product_space#Euclidean_space), and $||x||:=\\sqrt{\\langle x,x \\rangle}$. \n",
    "\n",
    "Write function `vector_angles` that gets two arrays X and Y with same shape (n,m) as parameters. Each row in the arrays corresponds to a vector. The function should return vector of shape (n,) with the corresponding angles between vectors of `X` and `Y` in degrees, not in radians. Again, don't use loops, but use vectorized operations.\n",
    "\n",
    "Note: function `np.arccos` is only defined on the domain [-1.0,1.0]. If you try to compute `np.arccos(1.000000001)`, it will fail. These kind of errors can occur due to use of finite precision in numerical computations. Force the argument to be in the correct range.\n",
    "\n",
    "Test your solution in the main program."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Broadcasting\n",
    "\n",
    "We have seen that NumPy allows array operations that are performed element-wise. But NumPy also allows binary operations that don't require the two arrays to have the same shape. For example, we can add 3 to all elements of an array with the following expression:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([4, 5, 6])"
      ]
     },
     "execution_count": 50,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.arange(3) + np.array([4])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In fact, because an array with only one element, say 3, can be thought of as a scalar 3, NumPy allows the following expression, which is equivalent to the above:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([4, 5, 6])"
      ]
     },
     "execution_count": 51,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.arange(3) + 4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To get can idea of what operations are allowed, i.e. what shapes of the two arrays are compatible, it can be useful to think that before the binary operation is performed, NumPy tries to stretch the arrays to have the same shape. For example in above NumPy first stretched the array `np.array([4])` (or the scalar 4), to the array `np.array([4,4,4])` and then performed the element-wise addition. In NumPy this stretching is called *broadcasting*. TÄHÄN KUVA TILANTEESTA."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The argument arrays can of course have higher dimensions, as the next example shows:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[5 5 5]\n",
      " [5 5 5]\n",
      " [5 5 5]]\n",
      "[0 1 2]\n",
      "[[5 6 7]\n",
      " [5 6 7]\n",
      " [5 6 7]]\n"
     ]
    }
   ],
   "source": [
    "a=np.full((3,3), 5)\n",
    "b=np.arange(3)\n",
    "print(a)\n",
    "print(b)\n",
    "print(a+b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In this example the second argument was first broadcasted to the array"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0, 1, 2],\n",
       "       [0, 1, 2],\n",
       "       [0, 1, 2]])"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.array([[0, 1, 2],\n",
    "       [0, 1, 2],\n",
    "       [0, 1, 2]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "and then the addition was performed. And it may be that both of the argument arrays need to be broadcasted as in the next example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a has dim 1, shape (3,), size 3, and dtype int64:\n",
      "[0 1 2]\n",
      "b has dim 2, shape (3, 1), size 3, and dtype int64:\n",
      "[[0]\n",
      " [1]\n",
      " [2]]\n",
      "a+b has dim 2, shape (3, 3), size 9, and dtype int64:\n",
      "[[0 1 2]\n",
      " [1 2 3]\n",
      " [2 3 4]]\n"
     ]
    }
   ],
   "source": [
    "a=np.arange(3)\n",
    "b=np.arange(3).reshape((3,1))\n",
    "info(\"a\", a)\n",
    "info(\"b\", b)\n",
    "info(\"a+b\", a+b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To see what the arguments were broadcasted to before the binary operation, the function `np.broadcast_arrays` can be used:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "broadcasted_a has dim 2, shape (3, 3), size 9, and dtype int64:\n",
      "[[0 1 2]\n",
      " [0 1 2]\n",
      " [0 1 2]]\n",
      "broadcasted_b has dim 2, shape (3, 3), size 9, and dtype int64:\n",
      "[[0 0 0]\n",
      " [1 1 1]\n",
      " [2 2 2]]\n"
     ]
    }
   ],
   "source": [
    "broadcasted_a, broadcasted_b = np.broadcast_arrays(a,b)\n",
    "info(\"broadcasted_a\", broadcasted_a)\n",
    "info(\"broadcasted_b\", broadcasted_b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So, both arrays were broadcasted, but in different ways. Let's next go through the [rules](https://docs.scipy.org/doc/numpy-1.14.0/reference/ufuncs.html#broadcasting) how the broadcasting work.\n",
    "\n",
    "\n",
    "1. All input arrays with ndim smaller than the input array of largest ndim, have 1’s prepended to their shapes.\n",
    "2. The size in each dimension of the output shape is the maximum of all the input sizes in that dimension.\n",
    "3. An input can be used in the calculation if its size in a particular dimension either matches the output size in that dimension, or has value exactly 1.\n",
    "4. If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the ufunc will simply not step along that dimension (the stride will be 0 for that dimension).\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally an example of a situation where the two array are not compatible:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [],
   "source": [
    "a=np.array([1,2,3])\n",
    "b=np.array([4,5])\n",
    "#a+b                 # This does not work since it violates the rule 3 above."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (multiplication table revisited)</div>\n",
    "Write function `multiplication_table` that gets a positive integer `n` as parameter. The function should return an array with shape (n,n). The element at index `(i,j)` should be `i*j`. Don't use `for` loops! In your solution, rely on broadcasting, the `np.arange` function, reshaping and vectorized operators. Example of usage:\n",
    "````\n",
    "print(multiplication_table(4))\n",
    "[[0 0 0 0]\n",
    " [0 1 2 3]\n",
    " [0 2 4 6]\n",
    " [0 3 6 9]]\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Comparisons and masking\n",
    "\n",
    "Just like NumPy allows element-wise arithmetic operations between arrays, for example addition of two arrays, it is possible to compare two arrays element-wise. For example"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ True False  True]\n"
     ]
    }
   ],
   "source": [
    "a=np.array([1,3,4])\n",
    "b=np.array([2,2,7])\n",
    "c = a < b\n",
    "print(c)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we can query weather all comparisons resulted True, or whether some comparison resulted True:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "False\n",
      "True\n"
     ]
    }
   ],
   "source": [
    "print(c.all())   # were all True\n",
    "print(c.any())   # was some comparison True"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also count the number of comparisons that were True. This solution relies on the interpretation that True corresponds to 1 and False corresponds to 0:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2\n"
     ]
    }
   ],
   "source": [
    "print(np.sum(c))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Because the broadcasting rules apply also to comparison, we can write"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ True  True  True]\n"
     ]
    }
   ],
   "source": [
    "print(a > 0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To try these operations on real data, we download some weather statistics from Helsinki (Kumpula) weather statition. More precisely we will get the daily average temperatures from year 2017. We use the pandas library, which we will cover later during this course, to load the data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "a=pd.read_csv(\"https://www.cs.helsinki.fi/u/jttoivon/dap/data/fmi/kumpula-weather-2017.csv\")['Air temperature (degC)'].values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([  0.6,  -3.9,  -6.5, -12.8, -17.8, -17.8,  -3.8,  -0.5,   0.5,\n",
       "         1.7,  -1.6,  -2.8,   1.1,   0.8,  -2.8,  -4.2,  -3.5,   1.1,\n",
       "         1.6,  -0.6,  -1.8,   1. ,   0.1,  -2.2,  -3.8,   1.9,   1.6,\n",
       "         0.8,   0.6,   1. ,   0.2,  -0.6,  -0.8,  -0.2,   0.4,  -2.5,\n",
       "        -7.3, -12.1,  -8.8, -10.1,  -8.3,  -5.4,  -2.7,   1.5,   4.4,\n",
       "         0. ,   0.5,   1.5,   1.9,   2.2,   0.4,  -2.5,  -4.6,  -0.7,\n",
       "        -5.3,  -5.6,  -2. ,  -2.3,   2.1,   1.5,   1.5,   0.9,  -1.8,\n",
       "        -4.2,  -4.2,  -2.9,   0.2,   1.2,   1.4,   2.2,  -0.9,   0.6,\n",
       "         0.6,   3.8,   3.4,   2. ,   1.6,   0.6,   0.2,   1.6,   2.3,\n",
       "         2.5,   0.5,   1.9,   4.8,   6.6,   2.4,   0.4,  -0.4,   0.2,\n",
       "         1.5,   4.3,   3. ,   3.8,   3.3,   4.7,   4.1,   3.3,   3.7,\n",
       "         6. ,   4.3,   1.8,   1.2,  -0.5,  -1.4,  -1.7,   0.6,   0.3,\n",
       "         1.2,   2.5,   5.7,   3.1,   2.9,   3.6,   2.8,   3.2,   4.4,\n",
       "         4.1,   2.3,   2.2,   7.6,   9.4,   9.2,   6.7,  10.1,  11.1,\n",
       "         6.1,   4.4,   1.5,   1.5,   2.9,   5.1,   7.5,   9.8,   9. ,\n",
       "         7.3,   9.4,  11.2,  16.1,  16.9,  14.7,  14.6,  13.3,  12.4,\n",
       "        14.1,  14.1,   9.6,  13.2,  14.1,   9.6,  10.8,   6.5,   6.2,\n",
       "        10. ,   9.9,  10.4,  14.5,  16.4,  12.3,  14. ,  16.3,  16.8,\n",
       "        12.6,  12.6,  14.8,  15.1,  18.4,  19.3,  16.9,  17.8,  12.7,\n",
       "        12.4,  12.2,  10.8,  12.9,  14. ,  13.5,  13.7,  15.3,  16.3,\n",
       "        17.2,  14.1,  16.4,  14.5,  14.1,  14. ,  11.5,  14.7,  16.1,\n",
       "        17.4,  18. ,  16.8,  16.8,  14.7,  15.3,  16.7,  18. ,  15.4,\n",
       "        15. ,  13.7,  14.6,  15.8,  15.6,  16.9,  15.7,  16.1,  17.2,\n",
       "        19. ,  19.1,  17.8,  18.3,  17.8,  18.9,  17.5,  18.2,  16.6,\n",
       "        17.1,  16. ,  15.2,  17.2,  18.3,  18.7,  18.1,  19.6,  17.4,\n",
       "        16.1,  16.4,  17.6,  19. ,  18. ,  18.2,  17.4,  16.2,  14.9,\n",
       "        13.5,  12.9,  11.2,  10.4,  10.7,  12. ,  14.4,  16.8,  17.2,\n",
       "        15.1,  12.9,  12.9,  11.9,  11.4,  10.4,  10.3,  10.6,  13.1,\n",
       "        14.6,  14.6,  14.9,  14.4,  12.9,  12.2,  12.1,   9.9,   8.7,\n",
       "         9. ,   9.2,  12.4,  11.5,  12.8,  12.5,  12.6,  12. ,  12.1,\n",
       "        10.1,   8.9,   8.8,   9.1,   9.2,   8.3,  11.2,   8.8,   7.7,\n",
       "         8.1,   9.3,   8.6,   8.1,   6.9,   6. ,   7.5,   7.2,   8.3,\n",
       "        10.7,   8.5,   8.3,   4.6,   2. ,   0.2,   0.1,   1.3,   0.8,\n",
       "         2.1,   0.3,  -0.3,   3.3,   2.1,   1.2,  -0.4,   0.1,   0.5,\n",
       "         3.2,   8. ,   8.4,   7.5,   3.9,   5.9,   6.7,   7.2,   5.9,\n",
       "         3.1,   2.4,   1.8,   3.1,   3.5,   5.8,   5.9,   4. ,   1.2,\n",
       "         0.9,   1. ,   1.5,   6.1,   4.2,   2.3,   4.6,   3.9,   2.8,\n",
       "         3.1,   0.9,   1.4,   5. ,   1.3,   0. ,  -1.2,  -0.8,   5.2,\n",
       "         4.2,   2. ,   1.4,   1.6,   1.6,   1.6,   1.7,   2.4,   0.1,\n",
       "         2. ,   1. ,   2.6,   2.5,  -0.1,   1.2,  -0.3,   0.3,   1.9,\n",
       "         3.8,   2.8,   3.8,   2.5,   1.6])"
      ]
     },
     "execution_count": 62,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of days with the temperature below zero 49\n"
     ]
    }
   ],
   "source": [
    "print(\"Number of days with the temperature below zero\", np.sum(a < 0))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In core Python we can combine truth values using the `and`, `or`, and `not` keywords. For boolean array however we have to use operators `&`, `|`, and `~`, respectively. An example of these:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "185"
      ]
     },
     "execution_count": 64,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.sum((0 < a) & (a < 10))     # Temperature is greater than 0 and smaller that 10 "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that we had to use parentheses around the comparisons, because the precedence of the `&` is higher than of `<`, and so it would have been performed before the comparisons."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Another use of boolean arrays is that they can be used to select a subset of elements. For example"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ True False False False False False False False  True  True]\n",
      "[ 0.6  0.5  1.7  1.1  0.8  1.1  1.6  1.   0.1  1.9  1.6  0.8  0.6  1.\n",
      "  0.2  0.4  1.5  4.4  0.5  1.5  1.9  2.2  0.4  2.1  1.5  1.5  0.9  0.2\n",
      "  1.2  1.4  2.2  0.6  0.6  3.8  3.4  2.   1.6  0.6  0.2  1.6  2.3  2.5\n",
      "  0.5  1.9  4.8  6.6  2.4  0.4  0.2  1.5  4.3  3.   3.8  3.3  4.7  4.1\n",
      "  3.3  3.7  6.   4.3  1.8  1.2  0.6  0.3  1.2  2.5  5.7  3.1  2.9  3.6\n",
      "  2.8  3.2  4.4  4.1  2.3  2.2  7.6  9.4  9.2  6.7 10.1 11.1  6.1  4.4\n",
      "  1.5  1.5  2.9  5.1  7.5  9.8  9.   7.3  9.4 11.2 16.1 16.9 14.7 14.6\n",
      " 13.3 12.4 14.1 14.1  9.6 13.2 14.1  9.6 10.8  6.5  6.2 10.   9.9 10.4\n",
      " 14.5 16.4 12.3 14.  16.3 16.8 12.6 12.6 14.8 15.1 18.4 19.3 16.9 17.8\n",
      " 12.7 12.4 12.2 10.8 12.9 14.  13.5 13.7 15.3 16.3 17.2 14.1 16.4 14.5\n",
      " 14.1 14.  11.5 14.7 16.1 17.4 18.  16.8 16.8 14.7 15.3 16.7 18.  15.4\n",
      " 15.  13.7 14.6 15.8 15.6 16.9 15.7 16.1 17.2 19.  19.1 17.8 18.3 17.8\n",
      " 18.9 17.5 18.2 16.6 17.1 16.  15.2 17.2 18.3 18.7 18.1 19.6 17.4 16.1\n",
      " 16.4 17.6 19.  18.  18.2 17.4 16.2 14.9 13.5 12.9 11.2 10.4 10.7 12.\n",
      " 14.4 16.8 17.2 15.1 12.9 12.9 11.9 11.4 10.4 10.3 10.6 13.1 14.6 14.6\n",
      " 14.9 14.4 12.9 12.2 12.1  9.9  8.7  9.   9.2 12.4 11.5 12.8 12.5 12.6\n",
      " 12.  12.1 10.1  8.9  8.8  9.1  9.2  8.3 11.2  8.8  7.7  8.1  9.3  8.6\n",
      "  8.1  6.9  6.   7.5  7.2  8.3 10.7  8.5  8.3  4.6  2.   0.2  0.1  1.3\n",
      "  0.8  2.1  0.3  3.3  2.1  1.2  0.1  0.5  3.2  8.   8.4  7.5  3.9  5.9\n",
      "  6.7  7.2  5.9  3.1  2.4  1.8  3.1  3.5  5.8  5.9  4.   1.2  0.9  1.\n",
      "  1.5  6.1  4.2  2.3  4.6  3.9  2.8  3.1  0.9  1.4  5.   1.3  5.2  4.2\n",
      "  2.   1.4  1.6  1.6  1.6  1.7  2.4  0.1  2.   1.   2.6  2.5  1.2  0.3\n",
      "  1.9  3.8  2.8  3.8  2.5  1.6]\n"
     ]
    }
   ],
   "source": [
    "c = a > 0\n",
    "print(c[:10])    # print only the first ten elements\n",
    "print(a[c])      # Select only the positive temperatures "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This operation is called *masking*. It can also be used to assign a new value. For example the following zeroes out the  negative temperatures:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 0.6  0.   0.   0.   0.   0.   0.   0.   0.5  1.7  0.   0.   1.1  0.8\n",
      "  0.   0.   0.   1.1  1.6  0.   0.   1.   0.1  0.   0.   1.9  1.6  0.8\n",
      "  0.6  1.   0.2  0.   0.   0.   0.4  0.   0.   0.   0.   0.   0.   0.\n",
      "  0.   1.5  4.4  0.   0.5  1.5  1.9  2.2  0.4  0.   0.   0.   0.   0.\n",
      "  0.   0.   2.1  1.5  1.5  0.9  0.   0.   0.   0.   0.2  1.2  1.4  2.2\n",
      "  0.   0.6  0.6  3.8  3.4  2.   1.6  0.6  0.2  1.6  2.3  2.5  0.5  1.9\n",
      "  4.8  6.6  2.4  0.4  0.   0.2  1.5  4.3  3.   3.8  3.3  4.7  4.1  3.3\n",
      "  3.7  6.   4.3  1.8  1.2  0.   0.   0.   0.6  0.3  1.2  2.5  5.7  3.1\n",
      "  2.9  3.6  2.8  3.2  4.4  4.1  2.3  2.2  7.6  9.4  9.2  6.7 10.1 11.1\n",
      "  6.1  4.4  1.5  1.5  2.9  5.1  7.5  9.8  9.   7.3  9.4 11.2 16.1 16.9\n",
      " 14.7 14.6 13.3 12.4 14.1 14.1  9.6 13.2 14.1  9.6 10.8  6.5  6.2 10.\n",
      "  9.9 10.4 14.5 16.4 12.3 14.  16.3 16.8 12.6 12.6 14.8 15.1 18.4 19.3\n",
      " 16.9 17.8 12.7 12.4 12.2 10.8 12.9 14.  13.5 13.7 15.3 16.3 17.2 14.1\n",
      " 16.4 14.5 14.1 14.  11.5 14.7 16.1 17.4 18.  16.8 16.8 14.7 15.3 16.7\n",
      " 18.  15.4 15.  13.7 14.6 15.8 15.6 16.9 15.7 16.1 17.2 19.  19.1 17.8\n",
      " 18.3 17.8 18.9 17.5 18.2 16.6 17.1 16.  15.2 17.2 18.3 18.7 18.1 19.6\n",
      " 17.4 16.1 16.4 17.6 19.  18.  18.2 17.4 16.2 14.9 13.5 12.9 11.2 10.4\n",
      " 10.7 12.  14.4 16.8 17.2 15.1 12.9 12.9 11.9 11.4 10.4 10.3 10.6 13.1\n",
      " 14.6 14.6 14.9 14.4 12.9 12.2 12.1  9.9  8.7  9.   9.2 12.4 11.5 12.8\n",
      " 12.5 12.6 12.  12.1 10.1  8.9  8.8  9.1  9.2  8.3 11.2  8.8  7.7  8.1\n",
      "  9.3  8.6  8.1  6.9  6.   7.5  7.2  8.3 10.7  8.5  8.3  4.6  2.   0.2\n",
      "  0.1  1.3  0.8  2.1  0.3  0.   3.3  2.1  1.2  0.   0.1  0.5  3.2  8.\n",
      "  8.4  7.5  3.9  5.9  6.7  7.2  5.9  3.1  2.4  1.8  3.1  3.5  5.8  5.9\n",
      "  4.   1.2  0.9  1.   1.5  6.1  4.2  2.3  4.6  3.9  2.8  3.1  0.9  1.4\n",
      "  5.   1.3  0.   0.   0.   5.2  4.2  2.   1.4  1.6  1.6  1.6  1.7  2.4\n",
      "  0.1  2.   1.   2.6  2.5  0.   1.2  0.   0.3  1.9  3.8  2.8  3.8  2.5\n",
      "  1.6]\n"
     ]
    }
   ],
   "source": [
    "a[~c] = 0\n",
    "print(a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Compare this result with the original array `a` to make sure you understand what's going on!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (column comparison)</div>\n",
    "\n",
    "Write function `column_comparison` that gets a two dimensional array as parameter. The function should return a new array containing those rows from the input that have the value in the second column larger than in the second last column. You may assume that the input contains at least two columns. Don't use loops, but instead vectorized operations. Try out your function in the main function. Example input and output:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (first half second half)</div>\n",
    "\n",
    "Write function `first_half_second_half` that gets a two dimensional array of shape `(n,2*m)` as a parameter. The input array has `2*m` columns. The output from the function should be a matrix with those rows from the input that have the sum of the first `m` elements larger than the sum of the last `m` elements on the row. Your solution should call the `np.sum` function or the corresponding method exactly twice."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Fancy indexing\n",
    "\n",
    "Using indexing we can get a single elements from an array. If we wanted multiple (not necessarily contiguous) elements, we would have to index several times:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[12 15  0  3  3  7  9 19 18  4  6 12  1  6  7 14 17  5 13  8]\n",
      "[ 0  7 19]\n"
     ]
    }
   ],
   "source": [
    "np.random.seed(0)\n",
    "a=np.random.randint(0, 20,20)\n",
    "a2=np.array([a[2], a[5], a[7]])\n",
    "print(a)\n",
    "print(a2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "That's quite verbose. *Fancy indexing* provides a concise syntax for accessing multiple elements:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 0  7 19]\n",
      "[ 0  7 19]\n"
     ]
    }
   ],
   "source": [
    "idx=[2,5,7]           # List of indices\n",
    "print(a[idx])         # In fancy indexing in place of a single index, we can provide a list of indices\n",
    "print(a[[2,5,7]])     # Or directly"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also assign to multiple elements through fancy indexing:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[12 15 -1  3  3 -1  9 -1 18  4  6 12  1  6  7 14 17  5 13  8]\n"
     ]
    }
   ],
   "source": [
    "a[idx] = -1\n",
    "print(a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Fancy indexing works also for higher dimensional arrays:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[9 4 3 0]\n",
      " [3 5 0 2]\n",
      " [3 8 1 3]\n",
      " [3 3 7 0]]\n",
      "[4 3]\n"
     ]
    }
   ],
   "source": [
    "b=np.random.randint(0,10, (4,4))\n",
    "print(b)\n",
    "row=np.array([0,2])\n",
    "col=np.array([1,3])\n",
    "print(b[row, col])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that the result array was one dimensional! The shape of the result array is defined by the shape of the index arrays, not by the shape of the original array. The next example will demonstrate this."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0 0]\n",
      " [2 2]]\n",
      "[[1 3]\n",
      " [1 3]]\n",
      "[[4 0]\n",
      " [8 3]]\n"
     ]
    }
   ],
   "source": [
    "row2=np.array([[0, 0], [2,2]])\n",
    "col2=np.array([[1,3], [1,3]])\n",
    "print(row2)\n",
    "print(col2)\n",
    "print(b[row2, col2])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Both index arrays, row and col, had shape (2,2), so also the result was of shape (2,2). However, this form has some repetition in the indices. But we can rely that the broadcasting rules will enable us to avoid the repetition:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0]\n",
      " [2]]\n",
      "[[1 3]]\n",
      "[[4 0]\n",
      " [8 3]]\n"
     ]
    }
   ],
   "source": [
    "row2=row.reshape(2,1)   # has shape (2, 1)\n",
    "col2=col.reshape(1,2)   # has shape (1, 2)\n",
    "print(row2)\n",
    "print(col2)\n",
    "print(b[row2, col2])    # the index arrays will be broadcasted here to shape (2,2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "One can also combine normal indexing, slicing and fancy indexing:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[9, 3],\n",
       "       [3, 0],\n",
       "       [3, 1],\n",
       "       [3, 7]])"
      ]
     },
     "execution_count": 73,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "b[:,[0,2]]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Sorting arrays\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1 2 3 4 5]\n",
      "[2 1 4 3 5]\n"
     ]
    }
   ],
   "source": [
    "a=np.array([2,1,4,3,5])\n",
    "print(np.sort(a))          # Does not modify the argument\n",
    "print(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1 2 3 4 5]\n"
     ]
    }
   ],
   "source": [
    "a.sort()            # Modifies the argument\n",
    "print(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 9 9 0]\n",
      " [4 7 3 2]\n",
      " [7 2 0 0]\n",
      " [4 5 5 6]]\n"
     ]
    }
   ],
   "source": [
    "b=np.random.randint(0,10, (4,4))\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1, 2, 0, 0],\n",
       "       [4, 5, 3, 0],\n",
       "       [4, 7, 5, 2],\n",
       "       [7, 9, 9, 6]])"
      ]
     },
     "execution_count": 77,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.sort(b, axis=0)           # sort each column"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0, 1, 9, 9],\n",
       "       [2, 3, 4, 7],\n",
       "       [0, 0, 2, 7],\n",
       "       [4, 5, 5, 6]])"
      ]
     },
     "execution_count": 78,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.sort(b, axis=1)           # Sort each row"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A related operation is the argsort function. Which doesn't sort the elements, but returns the indices of the sorted elements. An example will demonstrate this:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Array a: [2 1 4 3 5]\n",
      "Indices: [1 0 3 2 4]\n"
     ]
    }
   ],
   "source": [
    "a=np.array([2,1,4,3,5])\n",
    "print(\"Array a:\", a)\n",
    "idx = np.argsort(a)\n",
    "print(\"Indices:\", idx)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "These indices say that the smallest element of the array is in position 1 of `a`, second smallest elements is in position 0 of `a`, third smallest is in position 3, and so on. We can verify that these indices will indeed order the elements using fancy indexing:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1 2 3 4 5]\n"
     ]
    }
   ],
   "source": [
    "print(a[idx])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (most frequent first)</div>\n",
    "\n",
    "Write function `most_frequent_first` that gets a two dimensional array and an index `c` of a column as parameters. The function should then return the array whose rows are sorted so that those rows with the most frequent element in column `c` come first, then come the rows with the second most frequent element in column `c`, and so on.\n",
    "\n",
    "Example of usage:\n",
    "```\n",
    "a:\n",
    " [[5 0 3 3 7 9 3 5 2 4]\n",
    " [7 6 8 8 1 6 7 7 8 1]\n",
    " [5 9 8 9 4 3 0 3 5 0]\n",
    " [2 3 8 1 3 3 3 7 0 1]\n",
    " [9 9 0 4 7 3 2 7 2 0]\n",
    " [0 4 5 5 6 8 4 1 4 9]\n",
    " [8 1 1 7 9 9 3 6 7 2]\n",
    " [0 3 5 9 4 4 6 4 4 3]\n",
    " [4 4 8 4 3 7 5 5 0 1]\n",
    " [5 9 3 0 5 0 1 2 4 2]]\n",
    "print(most_frequent_first(a, -1))\n",
    " [[4 4 8 4 3 7 5 5 0 1]\n",
    " [2 3 8 1 3 3 3 7 0 1]\n",
    " [7 6 8 8 1 6 7 7 8 1]\n",
    " [5 9 3 0 5 0 1 2 4 2]\n",
    " [8 1 1 7 9 9 3 6 7 2]\n",
    " [9 9 0 4 7 3 2 7 2 0]\n",
    " [5 9 8 9 4 3 0 3 5 0]\n",
    " [0 3 5 9 4 4 6 4 4 3]\n",
    " [0 4 5 5 6 8 4 1 4 9]\n",
    " [5 0 3 3 7 9 3 5 2 4]]\n",
    "```\n",
    "\n",
    "If we look at the last column, we see that the number 1 appears three times, then both numbers 2 and 0 appear twice, and lastly numbers 3, 9, and 4 appear only once. Note that, for example, among those rows that contain in column `c` a number that appear twice the order can be arbitrary.\n",
    "\n",
    "Hint: the function `np.unique` may be useful."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Matrix operations\n",
    "\n",
    "The `*` operator is NumPy corresponds to the element-wise product of two arrays. However, very often we would like to use the *matrix multiplication*. As a reminder, if $a$ and $b$ are two matrices with shapes $n \\times k$ and $k \\times m$ respectively, then the matrix product of $a$ and $b$ is the matrix $c$ with shape $n \\times m$, where $c_{ij} = \\sum_{h=1}^k a_{ih} b_{hj}$ for $1 \\le i \\le n$ and $1 \\le j \\le m$. In NumPy we can compute the matrix product using the `np.matmul` function or the `@` operator. An example of this:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[5 0]\n",
      " [3 3]\n",
      " [7 9]]\n",
      "[[3 5 2 4]\n",
      " [7 6 8 8]]\n"
     ]
    }
   ],
   "source": [
    "np.random.seed(0)\n",
    "a=np.random.randint(0,10, (3,2))\n",
    "b=np.random.randint(0,10, (2,4))\n",
    "print(a)\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "c has dim 2, shape (3, 4), size 12, and dtype int64:\n",
      "[[ 15  25  10  20]\n",
      " [ 30  33  30  36]\n",
      " [ 84  89  86 100]]\n"
     ]
    }
   ],
   "source": [
    "c=np.matmul(a,b)\n",
    "info(\"c\", c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 15  25  10  20]\n",
      " [ 30  33  30  36]\n",
      " [ 84  89  86 100]]\n"
     ]
    }
   ],
   "source": [
    "print(a@b)      # This can be more convenient when complex expressions are used"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So, matrices are just two dimensional arrays with the product defined differently from the element-wise product. Note that for the matrix product to be defined, the two matrices have to have compatible shapes. So the following would produce an error:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [],
   "source": [
    "# a@a   # Try uncommenting to see the error message"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's test some basic identities that should hold for an [invertible matrix](https://en.wikipedia.org/wiki/Invertible_matrix):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 6 7]\n",
      " [7 8 1]\n",
      " [5 9 8]]\n",
      "[[-0.61111111 -0.16666667  0.55555556]\n",
      " [ 0.56666667  0.3        -0.53333333]\n",
      " [-0.25555556 -0.23333333  0.37777778]]\n",
      "[[ 1.00000000e+00 -8.32667268e-17  4.44089210e-16]\n",
      " [-5.55111512e-17  1.00000000e+00  4.44089210e-16]\n",
      " [-4.44089210e-16  0.00000000e+00  1.00000000e+00]]\n",
      "[[ 1.00000000e+00  9.99200722e-16 -8.88178420e-16]\n",
      " [ 0.00000000e+00  1.00000000e+00  8.88178420e-16]\n",
      " [ 2.22044605e-16 -4.44089210e-16  1.00000000e+00]]\n"
     ]
    }
   ],
   "source": [
    "s=np.array([[1, 6, 7],\n",
    " [7, 8, 1],\n",
    " [5, 9, 8]])\n",
    "print(s)\n",
    "s_inv = np.linalg.inv(s)\n",
    "print(s_inv)\n",
    "print(s @ s_inv)                            # This should be pretty close to the identity matrix np.eye(3)\n",
    "print(s_inv @ s)                            # Same here"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[39 41 57]\n",
      "[1. 4. 2.]\n"
     ]
    }
   ],
   "source": [
    "x=np.array([1,4,2])\n",
    "y = s @ x                  # Transforms x to y\n",
    "print(y)\n",
    "print(s_inv @ y)           # Transforms y back to x"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (matrix power)</div>\n",
    "\n",
    "Repeat the functionality of the Numpy function `numpy.linalg.matrix_power`, which raises a square matrix of shape (m,m) to the `n`th power. Here the multiplication is the matrix multiplication. Square matrix `a` raised to power `n` is therefore `a @ a @ ... @ a` where `a` is repeated `n` times. When n is zero then $a^0$ is equal to `np.eye(m)`.\n",
    "\n",
    "Part 1.\n",
    "\n",
    "Write function `matrix_power` that gets as first argument a square matrix `a` and as second argument a non-negative integer `n`. The function should return the matrix `a` multiplied by itself `n-1` times.\n",
    "Use Python's reduce function and a generator expression.\n",
    "\n",
    "Part 2.\n",
    "\n",
    "Extend the `matrix_power` function.\n",
    "For negative powers, we define $a^{-1}$ to be equal to the multiplicative inverse of `a`. You can use NumPy's function `numpy.linalg.inv` for this. And you may assume that the input matrix is invertible."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (correlation)</div>\n",
    "\n",
    "Load the iris dataset using the provided function `load()` in the stub solution. The four columns of the returned array correspond to\n",
    "* sepal length (cm)\n",
    "* sepal width (cm)\n",
    "* petal length (cm)\n",
    "* petal width (cm)\n",
    "\n",
    "Part 1. What is the Pearson correlation between the variables `sepal length` and `petal length`. Compute this using the `scipy.stats.pearsonr` function. It returns a tuple whose first element is the correlation. Write a function `lengths` that loads the data and return the correlation.\n",
    "\n",
    "Part 2. What are the correlations between all the variables. Write a function `correlations` that returns an array of shape (4,4) containing the correlations. Use the function `np.corrcoef`. Which pair of variables is the most highly correlated?\n",
    "\n",
    "Note the input formats of both functions `pearsonr` and `corrcoef`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Solving system of linear equations"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The Scipy library has function [`np.linalg.solve`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html) to solve systems of linear equations. The `solve` function gets as parameters the coefficient matrix and the vector containing the constant term. Below is an example of the general system of linear equations\n",
    "\n",
    "\\\\(a_{11}x_1 + a_{12}x_2 + \\cdots a_{1m}x_m = b_1\\\\\n",
    "a_{21}x_1 + a_{22}x_2 + \\cdots a_{2m}x_m = b_2\\\\\n",
    "\\cdots\\\\\n",
    "a_{n1}x_1 + a_{n2}x_2 + \\cdots a_{nm}x_m = b_n\\\\\n",
    "\\\\)\n",
    "\n",
    "\n",
    "and the equivalent matrix form\n",
    "\\\\(A \\cdot x = b\\\\)\n",
    "where $A$ has shape `(n,m)`, the unknown $x$ has shape `(m,1)`, and $b$ has shape `(n,1)`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (meeting lines)</div>\n",
    "\n",
    "Write function `meeting_lines` that gets the coefficients of two lines as parameters and returns the point where the two lines meet. The equations for the lines are $y=a_1x + b_1$ and $y=a_2x + b_2$. Use the `np.linalg.solve` function. Create a main function to test your solution."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (meeting planes)</div>\n",
    "Write function `meeting_planes` that gets the coefficients of three planes as parameters and returns the point where the planes meet. The equations for the planes are:\n",
    "$z =a_1y + b_1x+ c_1$,\n",
    "$z =a_2y + b_2x+ c_2$, and\n",
    "$z =a_3y + b_3x+ c_3$.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### <div class=\"alert alert-info\"> Exercise X (almost meeting lines)</div>\n",
    "In the earlier \"meeting lines\" exercise there is a problem if the lines don't meet at all. Extend that solution so that it tells the meeting point if it exists, and otherwise finds the point that is closest to the both lines.\n",
    "You can use the `numpy.linalg.lstsq` for this.\n",
    "\n",
    "Example of usage:\n",
    "```\n",
    "(y, x), exact = almost_meeting_lines(1, 2, -1, 0)\n",
    "print(y, x, exact)\n",
    "1.000000 -1.000000 True\n",
    "```"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
